<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The World of Draelon – Campaign Primer (v18)</title>
<style>
  :root{--bg:#0b0d12;--panel:#141821;--panel-2:#1b2130;--accent:#c6f06e;--accent-2:#8ad9ff;--text:#e8ecf3;--muted:#9aa3b2;--shadow:0 10px 30px rgba(0,0,0,.45);--radius:14px}
  html,body{height:100%}
  *{-webkit-tap-highlight-color:transparent}
  body{margin:0;background:radial-gradient(1200px 800px at 70% 10%, #151926, #0b0d12 60%, #07090e);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}

  header.site{display:flex;align-items:center;justify-content:space-between;padding:14px 18px;background:#141821;border-bottom:1px solid #232a3a;box-shadow:0 8px 24px rgba(0,0,0,.4);position:sticky;top:0;z-index:50}
  header.site h1{margin:0;font-size:22px;color:var(--accent)}
  header.site .tag{font-size:12px;color:#cfd7eb}

  .primer{max-width:1000px;margin:16px auto 8px;padding:0 16px}
  .primer .card{background:var(--panel);border:1px solid #232a3a;border-radius:16px;box-shadow:var(--shadow);padding:16px}
  .primer h2{margin:0 0 8px;color:#bfe27a}
  .primer .md{color:#dbe2f6;line-height:1.6}

  .wrap{position:relative;height:74vh;min-height:440px;margin:12px auto 16px;max-width:1200px;border-radius:var(--radius);background:var(--panel);box-shadow:var(--shadow);overflow:hidden;z-index:0}
  svg#world{width:100%;height:100%;display:block;background:#0d111a;touch-action:none;user-select:none}

  .map-loading{position:absolute;left:10px;top:10px;z-index:11;background:rgba(9,13,20,.85);border:1px solid #2b354a;border-radius:10px;padding:6px 8px;font-size:12px;color:#cbd5e1;opacity:1;transform:translateY(0);transition:opacity .2s ease, transform .2s ease}
  .map-loading.hide{opacity:0;transform:translateY(-4px);pointer-events:none}

  .zoombar{position:absolute;left:12px;top:12px;display:flex;flex-direction:column;gap:8px;z-index:8}
  .btn{background:#101522;color:#e6edf8;border:1px solid #33405a;border-radius:10px;padding:8px 12px;cursor:pointer}
  .zoombar .btn{width:38px;height:38px;display:flex;align-items:center;justify-content:center}
  .gm-btn{position:absolute;top:12px;right:12px;z-index:9;background:var(--panel-2);border:1px solid #2b354a;border-radius:999px;padding:8px 12px;font-weight:700}
  .hint{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,.35);border:1px solid #2b354a;border-radius:8px;padding:6px 8px;font-size:12px;color:#cbd5e1;z-index:8}

  .cms{position:absolute;top:56px;right:12px;width:min(520px,calc(100% - 24px));max-height:calc(100% - 68px);background:var(--panel-2);border:1px solid #2b354a;border-radius:14px;box-shadow:var(--shadow);display:none;z-index:9;overflow:hidden}
  .cms.open{display:flex;flex-direction:column}
  .cms header{display:flex;gap:8px;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid #2b354a;flex-wrap:wrap}
  .cms header h2{font-size:14px;margin:0}
  .cms .cms-body{padding:12px;overflow:auto;display:grid;gap:10px}
  .row{display:grid;gap:6px}
  .row label{font-size:12px;color:#cbd5e1}
  .row input[type="text"],.row textarea,.row select,.row input[type="color"]{width:100%;box-sizing:border-box;background:#101522;color:#e6edf8;border:1px solid #33405a;border-radius:10px;padding:10px 12px}
  .row textarea{min-height:100px;resize:vertical}
  .list{border-top:1px dashed #33405a;padding-top:8px;display:grid;gap:6px}
  .item{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:8px 10px;background:#0f1420;border:1px solid #2b354a;border-radius:10px}
  .chip{font-size:11px;padding:2px 6px;border-radius:999px;background:#1a2335;border:1px solid #2b354a;color:#b9c4da}
  .btn.danger{border-color:#503038;background:#2a0f14;color:#ffb4bf}

  .feature{cursor:pointer;outline:none}
  .feature.region path{stroke-width:0;fill-opacity:.32;transition:fill-opacity .12s linear;filter:url(#fuzzyEdge)}
  .feature.region.hover path{fill-opacity:.37}
  .feature.region.selected path{fill-opacity:.45}
  .feature.point circle{stroke:#141821;stroke-width:3;fill:var(--accent)}
  .feature.point .label{font-size:36px;fill:#eaf3ff;pointer-events:none;paint-order:stroke;stroke:#0b0e15;stroke-width:6px}

  .edit-handle{fill:#fff;stroke:#000;stroke-width:1.5;cursor:grab}
  .edge-handle{fill:#8ad9ff;stroke:#0b0e15;stroke-width:1.2;opacity:.95;cursor:copy}

  .tooltip{position:absolute;z-index:20;display:none;min-width:220px;max-width:min(420px,78vw);background:rgba(15,20,32,.94);border:1px solid #2b354a;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.5);padding:10px 12px;opacity:0;transform:translateY(6px);transition:opacity .15s ease, transform .15s ease}
  .tooltip.show{display:block;opacity:1;transform:translateY(0)}
  .tooltip h3{margin:0 16px 6px 0;font-size:16px;color:#d7def0}
  .tooltip .md{margin:0;color:#dbe2f6;line-height:1.45}
  .tooltip .close{position:absolute;right:8px;top:6px;background:transparent;border:0;color:#cbd5e1;cursor:pointer;font-size:16px}

  @media (max-width:900px){ .wrap{height:70vh} }
</style>
</head>
<body>
<header class="site">
  <h1>The World of Draelon</h1>
  <span class="tag">Campaign Primer</span>
</header>

<section class="primer" id="introSection">
  <div class="card">
    <h2>World Introduction</h2>
    <div class="md" id="introRender">Loading…</div>
  </div>
</section>

<div class="wrap" id="wrap">
  <div class="map-loading" id="mapLoading">Loading map…</div>

  <div class="zoombar">
    <button class="btn" id="zoomIn" title="Zoom in">＋</button>
    <button class="btn" id="zoomOut" title="Zoom out">－</button>
    <button class="btn" id="zoomReset" title="Reset view">⤾</button>
  </div>
  <div class="hint" id="hint">Drag/Pan · Scroll/Pinch to zoom</div>

  <button class="gm-btn" id="gmBtn" title="GM Mode">GM</button>

  <div class="cms" id="cms">
    <header>
      <h2>GM Tools</h2>
      <div class="toolbar" style="display:flex;gap:8px;flex-wrap:wrap">
        <button class="btn" id="toolSelect" type="button">Select</button>
        <button class="btn" id="toolAddPoint" type="button">Add Point</button>
        <button class="btn" id="toolAddRegion" type="button">New Region</button>
        <button class="btn" id="toolAddShape" type="button">Add Shape to Region</button>
        <button class="btn" id="toolExport" type="button">Export</button>
        <label class="btn" for="importFile" style="cursor:pointer;">Import</label>
        <input id="importFile" type="file" accept="application/json" style="display:none;" />
      </div>
    </header>
    <div class="cms-body">
      <div class="row">
        <label for="mapPath">Map Image Path (root-relative, e.g. <code>/map/world-map.png</code>)</label>
        <input type="text" id="mapPath" placeholder="/map/world-map.png" />
        <button class="btn" id="reloadMap" type="button">Reload Map</button>
      </div>
      <div class="row">
        <label>Selected Feature</label>
        <select id="featurePicker"></select>
      </div>
      <div class="row">
        <label for="featName">Name (auto-saves)</label>
        <input id="featName" type="text" placeholder="e.g., Signika" />
      </div>
      <div class="row">
        <label for="featDesc">Lore / Notes (auto-saves)</label>
        <textarea id="featDesc" placeholder="Write lore or notes..."></textarea>
      </div>
      <div class="row" id="rowColor" style="display:none;">
        <label for="featColor">Region Colour (live)</label>
        <input id="featColor" type="color" value="#8ad9ff" />
      </div>
      <div class="row" id="pointDanger" style="display:none;">
        <button class="btn danger" id="deletePoint" type="button">Delete Point</button>
      </div>
      <div class="row" id="shapeManager" style="display:none;">
        <label>Shapes in Region</label>
        <div id="shapeList" class="list"></div>
      </div>
      <div class="list" id="featureList"></div>

      <div class="row">
        <label for="introEdit">World Introduction (Markdown)</label>
        <textarea id="introEdit" placeholder="# Welcome to Draelon"></textarea>
      </div>
      <div class="row">
        <label for="campaignEdit">Campaign Primer (Markdown)</label>
        <textarea id="campaignEdit" placeholder="# Signika Awakens"></textarea>
      </div>
    </div>
  </div>

  <div class="tooltip" id="tooltip" role="dialog" aria-live="polite" aria-hidden="true">
    <button class="close" id="tipClose" aria-label="Close">✕</button>
    <h3 id="tipTitle">Lore</h3>
    <div class="md" id="tipBody">Tap a location to view details.</div>
  </div>

  <svg id="world" viewBox="0 0 1000 600" preserveAspectRatio="xMidYMid meet" aria-label="Interactive world map">
    <defs>
      <filter id="fuzzyEdge" x="-4%" y="-4%" width="108%" height="108%">
        <feGaussianBlur in="SourceAlpha" stdDeviation="2.5" result="blur" />
        <feComposite in="SourceGraphic" in2="blur" operator="in" />
      </filter>
    </defs>
    <image id="mapImage" href="" x="0" y="0" width="1000" height="600" />
    <g id="regions"></g>
    <g id="points"></g>
    <g id="editHandles"></g>
  </svg>
</div>

<section class="primer" id="campaignSection">
  <div class="card">
    <h2>Campaign Primer</h2>
    <div class="md" id="campaignRender">Loading…</div>
  </div>
</section>

<script>
(async function(){
  const STORAGE_KEY='draelon.world.v18';
  const DEFAULT_REGION_COLOR='#8ad9ff';
  const DEFAULT_MAP_PATH='/map/world-map.png';
  const JSON_PATH='/world-data.json';

  // DOM
  const wrap=document.getElementById('wrap');
  const svg=document.getElementById('world');
  const gRegions=document.getElementById('regions');
  const gPoints=document.getElementById('points');
  const editHandles=document.getElementById('editHandles');
  const mapImage=document.getElementById('mapImage');
  const hint=document.getElementById('hint');
  const tooltip=document.getElementById('tooltip');
  const tipTitle=document.getElementById('tipTitle');
  const tipBody=document.getElementById('tipBody');
  const tipClose=document.getElementById('tipClose');
  const introRender=document.getElementById('introRender');
  const campaignRender=document.getElementById('campaignRender');
  const mapLoading=document.getElementById('mapLoading');

  // CMS refs
  const gmBtn=document.getElementById('gmBtn');
  const cms=document.getElementById('cms');
  const toolSelect=document.getElementById('toolSelect');
  const toolAddPoint=document.getElementById('toolAddPoint');
  const toolAddRegion=document.getElementById('toolAddRegion');
  const toolAddShape=document.getElementById('toolAddShape');
  const exportBtn=document.getElementById('toolExport');
  const importFile=document.getElementById('importFile');
  const featurePicker=document.getElementById('featurePicker');
  const featName=document.getElementById('featName');
  const featDesc=document.getElementById('featDesc');
  const featColor=document.getElementById('featColor');
  const rowColor=document.getElementById('rowColor');
  const pointDanger=document.getElementById('pointDanger');
  const deletePointBtn=document.getElementById('deletePoint');
  const shapeManager=document.getElementById('shapeManager');
  const shapeList=document.getElementById('shapeList');
  const featureList=document.getElementById('featureList');
  const introEdit=document.getElementById('introEdit');
  const campaignEdit=document.getElementById('campaignEdit');
  const mapPath=document.getElementById('mapPath');
  const reloadMapBtn=document.getElementById('reloadMap');
  const zoomIn=document.getElementById('zoomIn');
  const zoomOut=document.getElementById('zoomOut');
  const zoomReset=document.getElementById('zoomReset');

  // Load data: external JSON -> localStorage -> defaults
  let state = await loadExternal(JSON_PATH);
  if(!state){ console.warn('world-data.json not found, using localStorage/defaults'); state = loadLocal() || defaultState(); }
  if(!state.mapImage) state.mapImage = DEFAULT_MAP_PATH;
  state.primer = state.primer || { intro: defaultIntro(), campaign: defaultCampaign() };

  // Map meta
  let mapW = state.mapSize?.w || 1000;
  let mapH = state.mapSize?.h || 600;

  // Start zoomed/panned a bit
  let view={ x:0, y: Math.round(mapH*0.10), w: Math.round(mapW*0.70), h: Math.round(mapH*0.70) };
  applyView();

  // Runtime
  let gmOpen=false, currentTool='select', buildingRegion=null, buildingShapeTargetRegionId=null, selectedId=state.features[0]?.id||null, hoveredId=null, isDraggingFeature=false;

  // Pan/zoom touch handling
  let activePointers=new Map();
  let panReady=false; // true when pointerdown started on background
  let panStart=null;  // {sx,sy,vx,vy,d?}
  const PAN_THRESHOLD=4;

  // Primer render
  introEdit.value = state.primer.intro;
  campaignEdit.value = state.primer.campaign;
  introRender.innerHTML = mdToHtml(state.primer.intro);
  campaignRender.innerHTML = mdToHtml(state.primer.campaign);

  // Map and loader
  applyMapMetaFromState();
  mapPath.value = state.mapImage || DEFAULT_MAP_PATH;
  await setMapImagePath(state.mapImage);

  // Initial render
  render();

  // -------- Tooltip logic ----------
  function showTooltip(f, clientX, clientY){
    tipTitle.textContent = f.name || 'Lore';
    tipBody.innerHTML = mdToHtml(f.desc || '');
    const wrapRect = wrap.getBoundingClientRect();
    const tip = tooltip;
    tip.style.display='block';
    tip.setAttribute('aria-hidden','false');
    const desiredLeft = clientX - wrapRect.left + 12;
    const desiredTop  = clientY - wrapRect.top  - 12;
    const maxLeft = wrapRect.width - tip.offsetWidth - 10;
    const maxTop  = wrapRect.height - tip.offsetHeight - 10;
    const left = Math.max(10, Math.min(desiredLeft, Math.max(10, maxLeft)));
    const top  = Math.max(10, Math.min(desiredTop,  Math.max(10, maxTop)));
    tip.style.left = left + 'px';
    tip.style.top  = top  + 'px';
    tip.classList.add('show');
  }
  function hideTooltip(){
    tooltip.classList.remove('show');
    tooltip.style.display='none';
    tooltip.setAttribute('aria-hidden','true');
  }
  tipClose.addEventListener('click', (e)=>{ e.stopPropagation(); hideTooltip(); });
  document.addEventListener('click', (e)=>{
    const inTip = tooltip.contains(e.target);
    const onMap = e.target.closest('#world') != null;
    if(!inTip && !onMap) hideTooltip();
  }, true);

  // -------- Handlers --------
  function attachRegionGroupHandlers(g, f){
    const isCoarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
    g.addEventListener('pointerenter', ()=>{ if(isCoarse) return; hoveredId=f.id; selectedId=f.id; updateStates(); });
    g.addEventListener('pointerleave', ()=>{ if(isCoarse) return; hoveredId=null; updateStates(); });
    g.addEventListener('click', (e)=>{ selectedId=f.id; updateStates(); showTooltip(f, e.clientX, e.clientY); if(gmOpen) selectFeature(f.id); });
  }
  function attachPointHandlers(node,f){
    node.addEventListener('click', (e)=>{ selectedId=f.id; updateStates(); showTooltip(f, e.clientX, e.clientY); if(gmOpen) selectFeature(f.id); });
    node.addEventListener('dblclick', (e)=>{ if(!gmOpen) return; e.stopPropagation(); if(confirm(`Delete point "${f.name}"?`)){ state.features = state.features.filter(x=>x.id!==f.id); if(selectedId===f.id) selectedId=null; render(); hideTooltip(); } });
    node.addEventListener('pointerdown', (e)=>{ if(!gmOpen) return; if(currentTool==='select' || currentTool==='add-point'){ selectFeature(f.id); startDragPoint(e, f); isDraggingFeature=true; } });
  }

  function updateStates(){ gRegions.querySelectorAll('.feature.region').forEach(g=>{ const id=g.getAttribute('data-id'); g.classList.toggle('hover', id===hoveredId); g.classList.toggle('selected', id===selectedId); }); }

  // -------- GM tools ----------
  function setTool(t){ currentTool=t; [toolSelect,toolAddPoint,toolAddRegion,toolAddShape].forEach(b=>b&&b.classList.remove('primary')); if(t==='select') toolSelect?.classList.add('primary'); if(t==='add-point') toolAddPoint?.classList.add('primary'); if(t==='add-region') toolAddRegion?.classList.add('primary'); if(t==='add-shape') toolAddShape?.classList.add('primary'); }
  setTool('select');
  gmBtn?.addEventListener('click', ()=>{ gmOpen=!gmOpen; cms?.classList.toggle('open', gmOpen); gmBtn.textContent = gmOpen? 'GM ✓' : 'GM'; updateHint(); render(); });
  function updateHint(){ hint.textContent = gmOpen ? 'Drag/Pan (background) · Pinch/Scroll to zoom · Shift-drag moves shape · Ctrl/⌘-drag moves region · Alt-click vertex deletes · Click mid-dot inserts · Double-click finishes new region' : 'Drag/Pan · Pinch/Scroll to zoom'; }
  updateHint();

  toolSelect.addEventListener('click', ()=> setTool('select'));
  toolAddPoint.addEventListener('click', ()=> setTool('add-point'));
  toolAddRegion.addEventListener('click', ()=> setTool('add-region'));
  toolAddShape.addEventListener('click', ()=>{
    const f = featureById(selectedId);
    if(!f || f.type!=='region'){ alert('Select a region first'); return; }
    buildingShapeTargetRegionId = f.id;
    buildingRegion = { id:f.id, type:'region', addingShape:true, shape:[] };
    setTool('add-shape');
  });

  // Add by click
  svg.addEventListener('click', (e)=>{
    if(!gmOpen) return; const pt = svgPoint(e);
    if(currentTool==='add-point'){
      const f = { id:uid(), type:'point', name:'New Point', desc:'', x:pt.x, y:pt.y };
      state.features.push(f); render(); selectFeature(f.id); showTooltip(f, e.clientX, e.clientY); return;
    }
    if(currentTool==='add-region'){
      if(!buildingRegion){
        const r = { id:uid(), type:'region', name:'New Region', color: DEFAULT_REGION_COLOR, desc:'', shapes:[[ {x:pt.x,y:pt.y} ]] };
        state.features.push(r); buildingRegion = r; selectedId=r.id; render(); selectFeature(r.id);
      } else {
        const shape = buildingRegion.shapes[buildingRegion.shapes.length-1];
        shape.push({x:pt.x,y:pt.y}); render(); selectFeature(buildingRegion.id);
      }
      return;
    }
    if(currentTool==='add-shape' && buildingRegion && buildingShapeTargetRegionId){
      const r = featureById(buildingShapeTargetRegionId); if(!r) return;
      if(!buildingRegion.shape.length){
        const s = 24; const half=s/2;
        const square=[{x:pt.x-half,y:pt.y-half},{x:pt.x+half,y:pt.y-half},{x:pt.x+half,y:pt.y+half},{x:pt.x-half,y:pt.y+half}];
        r.shapes.push(square);
        buildingRegion=null; buildingShapeTargetRegionId=null; setTool('select'); render(); selectFeature(r.id);
      }
      return;
    }
  });

  svg.addEventListener('dblclick', ()=>{
    if(!gmOpen) return;
    if(currentTool==='add-region'){
      const r=buildingRegion; if(!r) return;
      const shape=r.shapes[r.shapes.length-1];
      if(shape.length<3){ alert('Need at least 3 points for a shape.'); return; }
      buildingRegion=null; setTool('select'); render();
    }
  });

  // Drag helpers
  function startDragPoint(e, f){
    e.preventDefault();
    const start = svgPoint(e);
    const offset = { x: f.x - start.x, y: f.y - start.y };
    const move=(ev)=>{ const p=svgPoint(ev); f.x=clamp(p.x + offset.x,0,mapW); f.y=clamp(p.y + offset.y,0,mapH); render(); selectFeature(f.id,false); };
    const up=()=>{ off(move); isDraggingFeature=false; saveLocal(); };
    on(move,up);
  }
  function startDragShapeMove(e, f, sIdx){
    const p=svgPoint(e);
    const offset={x:p.x,y:p.y};
    const move=(ev)=>{ const q=svgPoint(ev); const dx=q.x-offset.x, dy=q.y-offset.y; f.shapes[sIdx]=f.shapes[sIdx].map(pt=>({x:clamp(pt.x+dx,0,mapW),y:clamp(pt.y+dy,0,mapH)})); offset.x=q.x; offset.y=q.y; render(); selectFeature(f.id,false); };
    const up=()=>{ off(move); isDraggingFeature=false; saveLocal(); };
    on(move,up);
  }
  function startDragRegionMove(e, f){
    const p=svgPoint(e);
    const offset={x:p.x,y:p.y};
    const move=(ev)=>{ const q=svgPoint(ev); const dx=q.x-offset.x, dy=q.y-offset.y; f.shapes=f.shapes.map(shape=> shape.map(pt=>({x:clamp(pt.x+dx,0,mapW),y:clamp(pt.y+dy,0,mapH)})) ); offset.x=q.x; offset.y=q.y; render(); selectFeature(f.id,false); };
    const up=()=>{ off(move); isDraggingFeature=false; saveLocal(); };
    on(move,up);
  }
  function on(move,up){ window.addEventListener('pointermove',move,{passive:false}); window.addEventListener('pointerup',up,{once:true}); }
  function off(move){ window.removeEventListener('pointermove',move); }

  // Pan & zoom (with safe start & pinch)
  function applyView(){ svg.setAttribute('viewBox', `${view.x} ${view.y} ${view.w} ${view.h}`); }
  function zoom(factor, center){
    const cx=center?.x ?? (view.x+view.w/2);
    const cy=center?.y ?? (view.y+view.h/2);
    const nw=clamp(view.w*factor, 200, mapW);
    const nh=clamp(view.h*factor, 120, mapH);
    view.x=clamp(cx-nw/2,0,Math.max(0,mapW-nw));
    view.y=clamp(cy-nh/2,0,Math.max(0,mapH-nh));
    view.w=nw; view.h=nh; applyView();
  }
  zoomIn.addEventListener('click', ()=> zoom(0.8));
  zoomOut.addEventListener('click', ()=> zoom(1.25));
  zoomReset.addEventListener('click', ()=>{ view={x:0,y:0,w:mapW,h:mapH}; applyView(); });

  // Start panning only if background (svg root or map image)
  svg.addEventListener('pointerdown', (e)=>{
    const target = e.target;
    const backgroundClick = (target===svg || target===mapImage);
    activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if(activePointers.size===1){
      panReady = backgroundClick;
      panStart={sx:e.clientX, sy:e.clientY, vx:view.x, vy:view.y};
    }
  }, true);

  svg.addEventListener('pointermove', (e)=>{
    if(activePointers.has(e.pointerId)) activePointers.set(e.pointerId, {x:e.clientX,y:e.clientY});

    // pinch zoom
    if(activePointers.size===2){
      e.preventDefault();
      const pts=[...activePointers.values()];
      const dCur=Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
      if(!panStart.d){ panStart.d=dCur; return; }
      const centerClient={x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2};
      const center=clientToSvg(centerClient);
      const factor = panStart.d>0 ? panStart.d/dCur : 1; // fingers apart => dCur bigger => factor<1 => zoom in
      zoom(factor, center);
      panStart.d=dCur;
      return;
    }

    // pan when ready and moved past threshold
    if(activePointers.size===1 && panReady){
      const dx=e.clientX-panStart.sx, dy=e.clientY-panStart.sy;
      if(!panStart.panning && Math.hypot(dx,dy) >= PAN_THRESHOLD){
        panStart.panning=true;
        svg.setPointerCapture(e.pointerId);
      }
      if(panStart.panning){
        e.preventDefault();
        const scaleX = view.w/svg.getBoundingClientRect().width;
        const scaleY = view.h/svg.getBoundingClientRect().height;
        view.x=clamp(panStart.vx - dx*scaleX,0,Math.max(0,mapW-view.w));
        view.y=clamp(panStart.vy - dy*scaleY,0,Math.max(0,mapH-view.h));
        applyView();
      }
    }
  }, {passive:false});

  svg.addEventListener('pointerup', (e)=>{
    activePointers.delete(e.pointerId);
    if(activePointers.size===0){ panReady=false; panStart=null; }
  });

  svg.addEventListener('wheel', (e)=>{ e.preventDefault(); const pt=svgPoint(e); const factor = e.deltaY>0 ? 1.15 : 0.85; zoom(factor, pt); }, {passive:false});

  // CMS UI + render
  function render(){
    gRegions.innerHTML=''; gPoints.innerHTML=''; editHandles.innerHTML='';

    state.features.filter(f=>f.type==='region').forEach(f=>{
      const g = elNS('g'); g.classList.add('feature','region'); g.setAttribute('data-id', f.id);
      const color = f.color || DEFAULT_REGION_COLOR;
      (f.shapes||[]).forEach((shape, sIdx)=>{
        if(!Array.isArray(shape) || shape.length<3) return;
        const path = elNS('path');
        path.setAttribute('d', roundedPolygonPath(shape, 10));
        path.setAttribute('fill', color);
        path.setAttribute('stroke', 'none');
        path.style.filter='url(#fuzzyEdge)';
        path.addEventListener('pointerdown', (e)=>{
          if(!(gmOpen && currentTool==='select')) return;
          const moveWhole = e.ctrlKey||e.metaKey;
          const moveShape = e.shiftKey;
          if(moveWhole){ startDragRegionMove(e, f); isDraggingFeature=true; e.stopPropagation(); }
          else if(moveShape){ startDragShapeMove(e, f, sIdx); isDraggingFeature=true; e.stopPropagation(); }
        });
        g.appendChild(path);
      });
      attachRegionGroupHandlers(g, f);
      gRegions.appendChild(g);

      if(selectedId===f.id && gmOpen){
        (f.shapes||[]).forEach((shape, sIdx)=>{
          shape.forEach((p,idx)=>{
            const h=elNS('circle'); h.setAttribute('cx',p.x); h.setAttribute('cy',p.y); h.setAttribute('r',6); h.classList.add('edit-handle');
            h.addEventListener('pointerdown',(e)=> startDragVertex(e,f,sIdx,idx));
            h.addEventListener('click',(e)=>{ e.preventDefault(); e.stopPropagation(); if(e.altKey){ deleteVertex(f,sIdx,idx); render(); } });
            editHandles.appendChild(h);
          });
          for(let i=0;i<shape.length;i++){
            const a=shape[i], b=shape[(i+1)%shape.length];
            const mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
            const m=elNS('circle'); m.setAttribute('cx',mx); m.setAttribute('cy',my); m.setAttribute('r',6); m.classList.add('edge-handle');
            m.addEventListener('click',(e)=>{ e.preventDefault(); e.stopPropagation(); insertVertexAtEdge(f,sIdx,i,{x:mx,y:my}); render(); });
            editHandles.appendChild(m);
          }
        });
      }
    });

    state.features.filter(f=>f.type==='point').forEach(f=>{
      const g=elNS('g'); g.classList.add('feature','point'); g.setAttribute('data-id', f.id);
      const c=elNS('circle'); c.setAttribute('cx',f.x); c.setAttribute('cy',f.y); c.setAttribute('r',18);
      const label=elNS('text'); label.setAttribute('x',f.x+30); label.setAttribute('y',f.y-30); label.classList.add('label'); label.textContent=f.name;
      g.appendChild(c); g.appendChild(label); attachPointHandlers(g,f); gPoints.appendChild(g);
    });

    refreshPicker(); refreshList(); updateStates(); refreshShapeListUI(); updatePointDanger(); saveLocal();
  }

  function refreshPicker(){ const id=selectedId; featurePicker.innerHTML = state.features.map(f=>`<option value="${f.id}">${escapeHTML(f.name)} (${f.type})</option>`).join(''); if(id){ const idx=state.features.findIndex(f=>f.id===id); featurePicker.selectedIndex = idx>=0 ? idx : 0; } onPickerChange(); }
  function refreshList(){ featureList.innerHTML=''; state.features.forEach(f=>{ const div=document.createElement('div'); div.className='item'; const tint=f.type==='region'?`<span class="chip" style="background:${f.color||DEFAULT_REGION_COLOR};color:#0b0e15;border:none">&nbsp;&nbsp;</span>`:''; div.innerHTML=`<div class="meta">${tint}<span class="chip">${f.type}</span><strong>${escapeHTML(f.name)}</strong></div><div class="toolbar" style="display:flex;gap:8px"><button class="btn" data-act="edit" type="button">Edit</button></div>`; div.querySelector('[data-act="edit"]').addEventListener('click', ()=>{ selectFeature(f.id); }); featureList.appendChild(div); }); }
  function onPickerChange(){ const id=featurePicker.value; if(!id) return; const f=state.features.find(x=>x.id===id); if(!f) return; selectedId=id; featName.value=f.name||''; featDesc.value=f.desc||''; if(f.type==='region'){ rowColor.style.display='grid'; featColor.value=(f.color||DEFAULT_REGION_COLOR); shapeManager.style.display='grid'; pointDanger.style.display='none'; } else { rowColor.style.display='none'; shapeManager.style.display='none'; pointDanger.style.display='grid'; } updateStates(); refreshShapeListUI(); }
  featurePicker.addEventListener('change', onPickerChange);
  function selectFeature(id, updatePicker=true){ selectedId=id; if(updatePicker) refreshPicker(); onPickerChange(); }
  function updatePointDanger(){ const f=state.features.find(x=>x.id===selectedId); pointDanger.style.display=(f && f.type==='point' && gmOpen)?'grid':'none'; }

  // SHAPE LIST UI (the missing function)
  function refreshShapeListUI(){
    const f = state.features.find(x=>x.id===selectedId);
    shapeList.innerHTML='';
    if(!f || f.type!=='region'){ shapeManager.style.display='none'; return; }
    shapeManager.style.display='grid';
    (f.shapes||[]).forEach((shape, idx)=>{
      const div=document.createElement('div'); div.className='item';
      div.innerHTML = `<div class="meta"><span class="chip">Shape ${idx+1}</span><span class="chip">${shape.length} pts</span></div>`+
                      `<div class="toolbar" style="display:flex;gap:8px"><button class="btn danger" data-del>Delete</button></div>`;
      div.querySelector('[data-del]').addEventListener('click', ()=>{
        if(!confirm('Delete this shape from the region?')) return;
        deleteShape(f, idx); render(); selectFeature(f.id);
      });
      shapeList.appendChild(div);
    });
  }

  // Auto-saves
  featName.addEventListener('input', ()=>{ const f=featureById(selectedId); if(!f) return; f.name=featName.value; refreshPicker(); refreshList(); saveLocal(); render(); });
  featDesc.addEventListener('input', ()=>{ const f=featureById(selectedId); if(!f) return; f.desc=featDesc.value; saveLocal(); });
  introEdit.addEventListener('input', ()=>{ state.primer.intro=introEdit.value; introRender.innerHTML=mdToHtml(state.primer.intro); saveLocal(); });
  campaignEdit.addEventListener('input', ()=>{ state.primer.campaign=campaignEdit.value; campaignRender.innerHTML=mdToHtml(state.primer.campaign); saveLocal(); });

  // Live color
  let colorRAF=0;
  featColor.addEventListener('input', ()=>{
    const f=featureById(selectedId); if(!f || f.type!=='region') return;
    f.color=featColor.value || DEFAULT_REGION_COLOR;
    if(colorRAF) cancelAnimationFrame(colorRAF);
    colorRAF=requestAnimationFrame(()=>{ updateRegionColorDOM(f); saveLocal(); });
  });
  function updateRegionColorDOM(f){
    const g=gRegions.querySelector(`.feature.region[data-id="${CSS.escape(f.id)}"]`);
    if(!g){ render(); return; }
    g.querySelectorAll('path').forEach(p=> p.setAttribute('fill', f.color || DEFAULT_REGION_COLOR));
  }

  deletePointBtn.addEventListener('click', ()=>{
    const f=featureById(selectedId); if(!f || f.type!=='point') return;
    if(!confirm(`Delete point "${f.name}"?`)) return;
    state.features=state.features.filter(x=>x.id!==f.id); selectedId=null; render(); hideTooltip();
  });

  reloadMapBtn.addEventListener('click', async ()=>{
    const path=(mapPath.value||'').trim() || DEFAULT_MAP_PATH;
    state.mapImage=path; showMapLoader(); await setMapImagePath(path); saveLocal();
  });

  // Export / Import (includes primer + map path + size)
  exportBtn.addEventListener('click', ()=>{
    try{
      const data=JSON.stringify({ mapImage: state.mapImage||'', mapSize: state.mapSize, features: state.features, primer: state.primer }, null, 2);
      const blob=new Blob([data],{type:'application/json'});
      const a=document.createElement('a'); const url=URL.createObjectURL(blob);
      a.href=url; a.download='draelon-world.json'; document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); },0);
    }catch(err){ alert('Export failed: '+(err?.message||err)); }
  });

  importFile.addEventListener('change', (e)=>{
    const file=e.target.files?.[0]; if(!file) return;
    const reader=new FileReader();
    reader.onload=async ()=>{
      try{
        const obj=JSON.parse(reader.result);
        if(obj.features) state.features=obj.features.map(f=>migrateFeature(f));
        if(obj.mapSize){ state.mapSize=obj.mapSize; mapW=state.mapSize.w; mapH=state.mapSize.h; mapImage.setAttribute('width',mapW); mapImage.setAttribute('height',mapH); svg.setAttribute('viewBox',`0 0 ${mapW} ${mapH}`); view={x:0,y:0,w:mapW,h:mapH}; }
        state.mapImage = obj.mapImage || DEFAULT_MAP_PATH;
        if(obj.primer) state.primer = { intro: obj.primer.intro||'', campaign: obj.primer.campaign||'' };
        introEdit.value=state.primer.intro; campaignEdit.value=state.primer.campaign;
        introRender.innerHTML=mdToHtml(state.primer.intro); campaignRender.innerHTML=mdToHtml(state.primer.campaign);
        mapPath.value=state.mapImage || DEFAULT_MAP_PATH;
        showMapLoader(); await setMapImagePath(state.mapImage);
        applyView(); render(); saveLocal();
      }catch(err){ alert('Invalid JSON'); }
    };
    reader.readAsText(file);
  });

  // ---- Map helpers (path only) ----
  function applyMapMetaFromState(){
    state.mapSize = state.mapSize || {w:1000,h:600};
    mapW = state.mapSize.w; mapH = state.mapSize.h;
    mapImage.setAttribute('width', mapW);
    mapImage.setAttribute('height', mapH);
    svg.setAttribute('viewBox',`0 0 ${mapW} ${mapH}`);
  }
  async function setMapImagePath(path){
    mapImage.removeAttribute('href');
    const done=()=> hideMapLoaderSoon();
    mapImage.addEventListener('load', done, {once:true});
    mapImage.addEventListener('error', ()=>{ console.warn('Map image failed to load:', path); done(); }, {once:true});
    mapImage.setAttribute('href', path || DEFAULT_MAP_PATH);
    setTimeout(hideMapLoaderSoon, 2500); // failsafe
  }
  function showMapLoader(){ mapLoading.classList.remove('hide'); }
  function hideMapLoaderSoon(){ mapLoading.classList.add('hide'); }

  // ---- Data utils ----
  function featureById(id){ return state.features.find(x=>x.id===id); }
  function uid(){ return Math.random().toString(36).slice(2)+Date.now().toString(36); }
  function saveLocal(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch(e){} }
  function loadLocal(){ try{ const s=localStorage.getItem(STORAGE_KEY); return s? migrate(JSON.parse(s)): null; }catch(e){ return null; } }
  async function loadExternal(path){ try{ const res=await fetch(path,{cache:'no-store'}); if(!res.ok) return null; const data=await res.json(); return migrate(data); }catch(e){ return null; } }
  function defaultIntro(){return `# Draelon at a Glance

*From the gilded courts of Oscana to the spellbound towers of Eturia, and the iron hosts of Athium—Draelon is a world of divided crowns and converging destinies.*

- **Oscana** – feudal realms, old blood, new money.
- **Athium** – an empire tempered for conquest.
- **Eturia** – a magocracy where scholarship is sovereignty.
- **Signika** – a northern island long ignored… until now.`;}
  function defaultCampaign(){return `# Signika Awakens

Monsters once thought myth now tread the forests of **Signika**—some wreathed in strange light, others touched by unheard-of magics. Guilds arrive in force:
- **Legio Xernacus** (Athium-backed)
- **Wyrm’s Hoard** (Oscanan mercenaries)
- **Eturian expeditions** (scholars with sharp minds and sharper wards)

Your choices will decide whose banners take root and which secrets stay buried.`;}
  function defaultState(){ return migrate({ mapImage: DEFAULT_MAP_PATH, mapSize:{w:1000,h:600}, primer:{ intro: defaultIntro(), campaign: defaultCampaign() }, features:[
    { id:uid(), type:'region', name:'Oscana', color:DEFAULT_REGION_COLOR, desc:'Western continent of divided kingdoms and feudal intrigue.', shapes:[[ {x:195,y:140},{x:415,y:150},{x:430,y:250},{x:300,y:270},{x:200,y:230} ]] },
    { id:uid(), type:'region', name:'Athium', color:DEFAULT_REGION_COLOR, desc:'Imperial power in the southeast; militarised and ambitious.', shapes:[[ {x:720,y:180},{x:900,y:190},{x:870,y:430},{x:690,y:410} ]] },
    { id:uid(), type:'region', name:'Eturia', color:DEFAULT_REGION_COLOR, desc:'Magocracy to the south—politics by spellbook.', shapes:[[ {x:480,y:450},{x:580,y:520},{x:520,y:580},{x:450,y:520} ], [ {x:600,y:480},{x:640,y:500},{x:620,y:530} ]] },
    { id:uid(), type:'point', name:'Signika', desc:'A wild northern island. Greywake port at the south. Recently crawling with strange, empowered monsters.', x:560, y:160 }
  ]});}
  function migrate(s){ if(!s) return null; if(!s.mapSize){ s.mapSize={w:1000,h:600}; } if(!s.primer){ s.primer={intro:defaultIntro(),campaign:defaultCampaign()}; } if(!s.mapImage){ s.mapImage=DEFAULT_MAP_PATH; } if(Array.isArray(s.features)) s.features=s.features.map(f=>migrateFeature(f)); return s; }
  function migrateFeature(f){ if(f.type==='region'){ if(!f.shapes && f.points){ f.shapes=[f.points]; delete f.points; } f.color=f.color||DEFAULT_REGION_COLOR; return f; } return f; }
  function svgPoint(evt){ const rect=svg.getBoundingClientRect(); const x=view.x + (evt.clientX-rect.left)*(view.w/rect.width); const y=view.y + (evt.clientY-rect.top)*(view.h/rect.height); return {x,y}; }
  function clientToSvg(pt){ const rect=svg.getBoundingClientRect(); const x=view.x + (pt.x-rect.left)*(view.w/rect.width); const y=view.y + (pt.y-rect.top)*(view.h/rect.height); return {x,y}; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function elNS(name){ return document.createElementNS('http://www.w3.org/2000/svg', name); }
  function escapeHTML(s){ return (s||'').replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }

  // Minimal Markdown
  function mdToHtml(md){
    md=(md||'');
    md=md.replace(/[&<>]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
    md=md.replace(/^######\s?(.*)$/gm,'<h6>$1</h6>')
         .replace(/^#####\s?(.*)$/gm,'<h5>$1</h5>')
         .replace(/^####\s?(.*)$/gm,'<h4>$1</h4>')
         .replace(/^###\s?(.*)$/gm,'<h3>$1</h3>')
         .replace(/^##\s?(.*)$/gm,'<h2>$1</h2>')
         .replace(/^#\s?(.*)$/gm,'<h1>$1</h1>');
    md=md.replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>')
         .replace(/\*(.*?)\*/g,'<em>$1</em>')
         .replace(/__(.*?)__/g,'<strong>$1</strong>')
         .replace(/_(.*?)_/g,'<em>$1</em>');
    md=md.replace(/^(?:- |\* )(.*)$/gm,'<li>$1</li>');
    md=md.replace(/(<li>.*<\/li>\n?)+/g, m=>`<ul>${m}</ul>`);
    md=md.split(/\n\n+/).map(p=>`<p>${p.replace(/\n/g,'<br/>')}</p>`).join('');
    return md;
  }

  // Geometry helpers
  function roundedPolygonPath(points, radius){
    const n=points.length; if(n<3) return '';
    const r=Math.max(0, radius|0);
    function lerp(a,b,t){ return {x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t}; }
    let d='';
    for(let i=0;i<n;i++){
      const p0=points[(i-1+n)%n], p1=points[i], p2=points[(i+1)%n];
      const rr=Math.min(r, dist(p1,p0)/2, dist(p1,p2)/2);
      const pA=lerp(p1,p0, rr/dist(p1,p0));
      const pB=lerp(p1,p2, rr/dist(p1,p2));
      if(i===0){ d += `M ${pA.x} ${pA.y} `; }
      d += `L ${pA.x} ${pA.y} Q ${p1.x} ${p1.y} ${pB.x} ${pB.y} `;
    }
    d+='Z'; return d;
  }
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

  // Vertex edits
  function startDragVertex(e,f,sIdx,idx){
    e.preventDefault(); e.stopPropagation();
    const start=svgPoint(e);
    const startPt={x:f.shapes[sIdx][idx].x, y:f.shapes[sIdx][idx].y};
    const offset={x:startPt.x-start.x, y:startPt.y-start.y};
    const move=(ev)=>{ const p=svgPoint(ev); f.shapes[sIdx][idx]={x:clamp(p.x+offset.x,0,mapW),y:clamp(p.y+offset.y,0,mapH)}; render(); selectFeature(f.id,false); };
    const up=()=>{ off(move); isDraggingFeature=false; saveLocal(); };
    on(move,up);
  }
  function insertVertexAtEdge(f,sIdx,i,p){ f.shapes[sIdx].splice(i+1,0,{x:p.x,y:p.y}); }
  function deleteVertex(f,sIdx,idx){ if(f.shapes[sIdx].length<=3){ deleteShape(f,sIdx); return; } f.shapes[sIdx].splice(idx,1); }
  function deleteShape(f,sIdx){ f.shapes.splice(sIdx,1); }

})();
</script>
</body>
</html>
