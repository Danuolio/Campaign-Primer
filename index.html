<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The World of Draelon – Campaign Primer (v56)</title>
  <style>
    :root{
      --bg:#efe7d2; --paper:#fbf3dd; --paper-2:#f6edd1; --ink:#2c2416; --ink-soft:#5c523f;
      --accent:#8b5e34; --rule:#d8caa6; --edge:#cbb98f; --shadow:0 18px 40px rgba(0,0,0,.25); --radius:16px;
      --wrap:clamp(895px, 90vw, 1400px);
      --gold:#e7d9b7; --ivory:#f6e7c8;
      --btn:#ead8aa; --btn2:#dfc98a;
    }
    html,body{height:100%}
    body{ margin:0; color:var(--ink);
      background: radial-gradient(1200px 800px at 60% 0%, #f9f1d9 0%, #efe7d2 60%, #e7dbbd 100%);
      font-family: Georgia, "Iowan Old Style", "Palatino Linotype", serif; line-height:1.4;
      -webkit-tap-highlight-color: transparent;
    }
    *{ user-select: none; -webkit-user-select: none; -ms-user-select: none; }
    input, textarea, select, .gm-modal, .cms, .island-lore, .primer, .side .content{
      user-select: text; -webkit-user-select: text;
    }
    .primer,.panel{
      background: linear-gradient(180deg, var(--paper), var(--paper-2));
      border: 1px solid var(--edge);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position:relative;
    }
    .primer::after,.panel::after{
      content:""; position:absolute; inset:0; pointer-events:none; border-radius: var(--radius);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.04), inset 0 30px 60px rgba(0,0,0,.06);
    }
    .primer{margin:16px; padding:18px 18px 14px}
    .primer h2{ margin:0 0 10px 0; font-size:26px; letter-spacing:.5px; text-transform:uppercase; font-weight:700; border-bottom:2px solid var(--rule); padding-bottom:6px; }
    .app{ display:grid; grid-template-columns: 1fr; gap:0; }
    .map-row{display:flex; justify-content:center}
    .map-wrap{
      position:relative;
      width:100%; max-width:var(--wrap);
      min-height:60vh; max-height:82vh;
      margin:16px; overflow:hidden;
    }
    @media (min-width: 1400px){ .map-wrap{ min-height:72vh; } }
    .map-wrap svg{
      width:100%; height:100%; display:block;
      background:#efe6c8;
      touch-action:none; cursor:grab;
    }
    .side-row{display:flex; justify-content:center}
    .side{
      width:100%; max-width:var(--wrap);
      display:flex;flex-direction:column;
      margin:0 16px 16px 16px; overflow:hidden;
    }
    .side header{padding:14px 16px;display:flex;align-items:center;justify-content:space-between;border-bottom:2px solid var(--rule);background:linear-gradient(180deg,var(--paper),var(--paper-2));border-top-left-radius:var(--radius);border-top-right-radius:var(--radius)}
    .side header h1{font-size:18px;margin:0;letter-spacing:.6px;text-transform:uppercase}
    .side .content{padding:16px;overflow:visible}
    .lore-title{font-weight:700;margin:0 0 8px;font-size:20px;letter-spacing:.2px}
    .lore-body{line-height:1.6;}
    .lore-media{margin:0 0 12px 0; display:none}
    .lore-media img{width:100%; height:auto; display:block; border-radius:10px; border:1px solid var(--edge); box-shadow: var(--shadow)}

    .muted{color:var(--ink-soft);font-size:12px}
    .loader{position:absolute;left:10px;top:10px;display:flex;align-items:center;gap:8px;background:rgba(255,255,255,.75);border:1px solid var(--edge);border-radius:10px;padding:6px 10px;z-index:20;backdrop-filter:blur(2px)}
    .spinner{width:14px;height:14px;border-radius:50%;border:2px solid rgba(0,0,0,.2); border-top-color:var(--accent); animation:spin .8s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .gm-btn{position:absolute;top:12px;right:12px;z-index:40;background:linear-gradient(180deg, #f7edcf, #efe2b6);color:var(--ink);border:1px solid var(--edge);border-radius:999px;padding:8px 12px;font-weight:700;cursor:pointer;box-shadow: var(--shadow)}
    .gm-btn.on{background:linear-gradient(180deg, #e7d69e, #e0c87e);}

    .feature{cursor:pointer}
    .feature.point circle{stroke:var(--paper);stroke-width:3;fill:var(--accent)}
    .feature.point .label{font-size:36px;fill:var(--ink);pointer-events:none;paint-order:stroke;stroke:#faedcf;stroke-width:6px;stroke-linejoin:round}
    .feature.region path.fill{transition:fill-opacity .12s linear; pointer-events:auto}
    .feature.region.hover path.fill{fill-opacity:.35}
    .feature.region.selected path.fill{fill-opacity:.42}

    .feature.region .ol-glow,
    .feature.region .ol-mid,
    .feature.region .ol-core{
      fill:none; stroke-linejoin:round; stroke-linecap:round;
      opacity:0; pointer-events:none; transition: opacity .12s linear;
    }
    .feature.region .ol-glow{ stroke-width:14; filter:url(#neonOuter); }
    .feature.region .ol-mid { stroke-width:8;  filter:url(#neonInner); }
    .feature.region .ol-core{ stroke:var(--ivory); stroke-width:2.5; }
    .feature.region.hover .ol-glow,
    .feature.region.hover .ol-mid,
    .feature.region.hover .ol-core{ opacity:.5; }
    .feature.region.selected .ol-glow,
    .feature.region.selected .ol-mid,
    .feature.region.selected .ol-core{ opacity:.7; }

    .tooltip{
      position:absolute;min-width:260px;max-width:420px;background:var(--paper);
      border:1px solid var(--edge);border-radius:12px;box-shadow: var(--shadow);
      z-index:1000;display:none;pointer-events:auto;overflow:auto;
    }
    .tooltip.open{display:block}
    .tooltip header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid var(--rule); background:linear-gradient(180deg,var(--paper),var(--paper-2)); position:sticky; top:0; z-index:2}
    .tooltip header h3{margin:0;font-size:16px}
    .tooltip .close{background:transparent;border:0;color:var(--ink);cursor:pointer;font-size:18px}
    .tooltip .media{width:100%;overflow:hidden;background:#e6d9b6;border-bottom:1px solid var(--rule)}
    .tooltip .media img{width:100%;height:auto;display:block}
    .tooltip .body{padding:10px 12px;line-height:1.5;}
    .tooltip .body p{margin:0}

    .section{margin:8px 16px 16px 16px; display:flex; justify-content:center;}
    .island-grid{ display:grid; grid-template-columns: 1fr 1fr; gap:16px; align-items:start; max-width:1280px; width:100%; }
    .island-card{ margin:0; padding:12px; background:linear-gradient(180deg, var(--paper), var(--paper-2));
      border:1px solid var(--edge); border-radius: var(--radius); box-shadow: var(--shadow);
      display:block; max-width:100%; }
    .island-card img{display:block; width:100%; height:auto}
    .island-lore{padding:16px}
    .island-lore h3{margin:0 0 8px 0;font-size:18px;text-transform:uppercase;letter-spacing:.4px}
    .island-lore .body{line-height:1.6}

    .gm-bar{
      position:absolute; left:12px; top:12px; z-index:45;
      background:linear-gradient(180deg, #fff7dd, #f2e5b7);
      border:1px solid var(--edge); border-radius:12px; padding:8px; display:none; gap:6px; align-items:center;
      box-shadow: var(--shadow);
    }
    body.gm-on .gm-bar{ display:flex; }
    .gm-bar .row{ display:flex; gap:6px; flex-wrap:wrap; align-items:center }
    .gm-bar label{ font-size:12px; color:var(--ink-soft) }
    .gm-bar input[type="text"], .gm-bar input[type="color"], .gm-bar select{
      font-size:12px; padding:4px 6px; border:1px solid var(--edge); border-radius:6px; background:#fffaf0;
    }
    .gm-bar button{
      font-size:12px; padding:6px 10px; border:1px solid var(--edge); border-radius:999px; cursor:pointer;
      background:linear-gradient(180deg, var(--btn), var(--btn2));
    }
    .gm-bar .sep{ width:1px; height:20px; background:var(--edge); margin:0 4px; }

    .gm-overlay .shape-path{ fill:rgba(255,255,240,.25); stroke:#8b5e34; stroke-width:2; }
    .gm-overlay .handle{ fill:#fff; stroke:#8b5e34; stroke-width:2; cursor:grab; }
    .gm-overlay .handle.drag{ cursor:grabbing; }
    .gm-overlay .edge{ stroke:rgba(139,94,52,.5); stroke-width:8; stroke-linecap:round; opacity:.0001; cursor:copy; }
    .gm-overlay .handle.del{ fill:#8b3434; stroke:#fff; }

    body.gm-on [contenteditable="true"]{
      outline: 2px dashed rgba(139,94,52,.45);
      background: linear-gradient(180deg, rgba(255,255,240,.35), rgba(255,255,220,.25));
      border-radius: 8px; padding: 6px; transition: background .2s ease;
    }
    body.gm-on [contenteditable="true"]:focus{ background: linear-gradient(180deg, rgba(255,255,230,.6), rgba(255,255,210,.45)); }

    @media (max-width: 760px){
      .tooltip{ display:none !important; }
      .map-wrap{ height: min(60vh, calc(100vw * 0.72)); min-height:auto; max-height:none; }
      .map-wrap svg{ height:100%; }
      .island-grid{ grid-template-columns: 1fr !important; grid-auto-flow: row !important; max-width: 720px; }
      .island-card{ max-width: 100% !important; width: 100% !important; order: 1 !important; }
      .island-lore{ order: 2 !important; margin-top: 12px !important; }
    }
  </style>
</head>
<body>
  <div class="primer" id="primerTop">
    <h2>The World of Draelon</h2>
    <div id="primerIntro">This is your editable campaign introduction. Enable GM mode to edit this text. Players can scroll the map, tap regions, and read tooltips.</div>
  </div>
  <div class="app">
    <div class="map-row">
      <div class="map-wrap panel" id="mapWrap">
        <div class="loader" id="loader" aria-live="polite"><div class="spinner"></div><span id="loaderText">Loading world…</span></div>
        <button class="gm-btn" id="gmBtn" title="GM Mode" type="button">GM</button>

        <div class="gm-bar" id="gmBar">
          <div class="row">
            <select id="regionSelect"></select>
            <button id="newRegionBtn" title="Create new region">+ Region</button>
            <span class="sep"></span>
            <label>Name</label><input id="regionName" type="text" size="12" />
            <label>Color</label><input id="regionColor" type="color" value="#8ad9ff" />
            <span class="sep"></span>
            <button id="addShapeBtn" title="Start a new polygon for this region">+ Shape</button>
            <button id="finishShapeBtn" title="Finish current shape">Finish</button>
            <button id="addVertexModeBtn" title="Click an edge to insert a vertex">Add Vertex</button>
            <button id="delVertexModeBtn" title="Click a vertex to delete it">Del Vertex</button>
            <span class="sep"></span>
            <button id="saveJsonBtn" title="Download world-data.json">Save JSON</button>
          </div>
        </div>

        <div class="tooltip" id="tooltip" role="dialog" aria-live="polite">
          <div class="media" id="ttMedia" style="display:none"><img id="ttImg" alt=""></div>
          <header>
            <h3 id="ttTitle">Title</h3>
            <button class="close" id="ttClose" aria-label="Close">×</button>
          </header>
          <div class="body" id="ttBody"></div>
        </div>

        <svg id="world" viewBox="0 0 1000 600" preserveAspectRatio="xMidYMid meet" aria-label="Interactive world map">
          <defs>
            <filter id="fuzzyEdge" x="-4%" y="-4%" width="108%">
              <feGaussianBlur in="SourceAlpha" stdDeviation="2.5" result="blur" />
              <feComposite in="SourceGraphic" in2="blur" operator="in" />
            </filter>
            <filter id="neonOuter" x="-30%" y="-30%" width="160%" height="160%">
              <feGaussianBlur stdDeviation="4" result="blur1"/>
              <feMerge><feMergeNode in="blur1"/><feMergeNode in="SourceGraphic"/></feMerge>
            </filter>
            <filter id="neonInner" x="-12%" y="-12%" width="124%" height="124%">
              <feGaussianBlur stdDeviation="1.5" result="blur3"/>
              <feMerge><feMergeNode in="blur3"/><feMergeNode in="SourceGraphic"/></feMerge>
            </filter>
          </defs>
          <image id="mapImage" href="" x="0" y="0" width="1000" height="600" preserveAspectRatio="none" />
          <g id="regions"></g>
          <g id="points"></g>
          <g id="gmOverlay" class="gm-overlay"></g>
        </svg>
      </div>
    </div>
    <div class="side-row">
      <aside class="side panel" id="sidePanel">
        <header><h1>Campaign Info</h1><span class="muted">Click the map to explore</span></header>
        <div class="content">
          <div class="lore-media" id="loreMedia"><img id="loreImg" alt=""></div>
          <h3 class="lore-title" id="loreTitle">Welcome</h3>
          <div class="lore-body" id="loreBody">Use the map to learn about regions like <b>Oscana</b>, <b>Athium</b>, <b>Eturia</b>, and the island of <b>Signika</b>.</div>
        </div>
      </aside>
    </div>
  </div>
  <section class="section">
    <div class="island-grid">
      <figure class="island-card"><img id="islandImg" src="" alt="Signika island map"/></figure>
      <div class="island-lore panel"><h3>Island Lore</h3><div id="islandLore" class="body">Add your Signika lore here — history, factions, features, and travel notes.</div></div>
    </div>
  </section>
  <div class="primer panel" id="primerBottom">
    <h2>Primer – Details</h2>
    <div id="primerDetails">Add your campaign factions, tone, safety tools, character hooks, and session 0 notes here. Enable GM mode to edit this section.</div>
  </div>
<script>
(function(){
  const JSON_PATH = './world-data.json?v=' + Date.now();
  const DEFAULT_WORLD_MAP = '/Campaign-Primer/map/world-map.png';
  const DEFAULT_ISLAND_MAP = '/Campaign-Primer/map/campaign-map.png';
  const LS_KEY = 'signika.world.v56';
  let state=null;

  const mapWrap  = document.getElementById('mapWrap');
  const svgWorld = document.getElementById('world');
  const mapImage = document.getElementById('mapImage');
  const gRegions = document.getElementById('regions');
  const gPoints  = document.getElementById('points');
  const gmOverlay= document.getElementById('gmOverlay');
  const islandImg = document.getElementById('islandImg');
  const islandLore = document.getElementById('islandLore');
  const primerIntro = document.getElementById('primerIntro');
  const primerDetails = document.getElementById('primerDetails');
  const loreTitle = document.getElementById('loreTitle');
  const loreBody  = document.getElementById('loreBody');
  const loreMedia = document.getElementById('loreMedia');
  const loreImg   = document.getElementById('loreImg');
  const loader = document.getElementById('loader');
  const tooltip = document.getElementById('tooltip');
  const ttTitle = document.getElementById('ttTitle');
  const ttBody  = document.getElementById('ttBody');
  const ttMedia = document.getElementById('ttMedia');
  const ttImg   = document.getElementById('ttImg');
  const ttClose = document.getElementById('ttClose');
  const gmBtn   = document.getElementById('gmBtn');
  const gmBar   = document.getElementById('gmBar');
  const regionSelect = document.getElementById('regionSelect');
  const regionName   = document.getElementById('regionName');
  const regionColor  = document.getElementById('regionColor');
  const addShapeBtn  = document.getElementById('addShapeBtn');
  const finishShapeBtn= document.getElementById('finishShapeBtn');
  const addVertexModeBtn= document.getElementById('addVertexModeBtn');
  const delVertexModeBtn= document.getElementById('delVertexModeBtn');
  const newRegionBtn = document.getElementById('newRegionBtn');
  const saveJsonBtn  = document.getElementById('saveJsonBtn');

  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const elNS=(n)=>document.createElementNS('http://www.w3.org/2000/svg',n);
  const escapeHTML = s => (s||'').replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  function renderMultiline(el, text){ el.innerHTML = escapeHTML(text || '').replace(/
/g, '<br>'); }

  function hexToRgb(hex){ hex=hex.replace('#',''); if(hex.length===3) hex=hex.split('').map(c=>c+c).join('');
    const n=parseInt(hex,16); return {r:(n>>16)&255, g:(n>>8)&255, b:n&255}; }
  function rgbToHex({r,g,b}){ const h=(v)=>('0'+v.toString(16)).slice(-2); return '#'+h(r)+h(g)+h(b); }
  function blendHex(a,b,t){ const A=hexToRgb(a), B=hexToRgb(b);
    const lerp=(x,y)=>Math.round(x+(y-x)*t);
    return rgbToHex({r:lerp(A.r,B.r), g:lerp(A.g,B.g), b:lerp(A.b,B.b)}); }

  function clientToSvg(x,y){
    const pt = svgWorld.createSVGPoint();
    pt.x = x; pt.y = y;
    const m = svgWorld.getScreenCTM().inverse();
    const sp = pt.matrixTransform(m);
    return {x: sp.x, y: sp.y};
  }

  function roundedPolygonPath(points, r){
    if(!points || points.length<2) return '';
    const n=points.length; let d='';
    for(let i=0;i<n;i++){
      const p0=points[(i-1+n)%n], p1=points[i], p2=points[(i+1)%n];
      const v1x=p1.x-p0.x, v1y=p1.y-p0.y, v2x=p2.x-p1.x, v2y=p2.y-p1.y;
      const l1=Math.hypot(v1x,v1y), l2=Math.hypot(v2x,v2y);
      const r1=Math.min(r, l1/3), r2=Math.min(r, l2/3);
      const A={x:p1.x - v1x/l1*r1, y:p1.y - v1y/l1*r1};
      const B={x:p1.x + v2x/l2*r2, y:p1.y + v2y/l2*r2};
      if(i===0) d+=`M ${A.x} ${A.y} `; else d+=`L ${A.x} ${A.y} `;
      d+=`Q ${p1.x} ${p1.y} ${B.x} ${B.y} `;
    }
    return d+'Z';
  }

  function computeCoverCrop(imgW, imgH, svgW, svgH){
    const aspect = svgW / svgH;
    let vw = Math.min(imgW, imgH * aspect);
    let vh = vw / aspect;
    if (vh > imgH) { vh = imgH; vw = vh * aspect; if (vw > imgW) { vw = imgW; vh = vw / aspect; } }
    return {vw, vh};
  }

  function makeBoundedNavigator(svgEl, imgW, imgH){
    function initialView(){
      const rect = svgEl.getBoundingClientRect();
      const {vw, vh} = computeCoverCrop(imgW, imgH, rect.width, rect.height);
      const vx = (imgW - vw) / 2;
      const vy = (imgH - vh) / 2;
      return {vx, vy, vw, vh};
    }
    let {vx,vy,vw,vh} = initialView();
    svgEl.setAttribute('viewBox', `${vx} ${vy} ${vw} ${vh}`);

    const nav={
      viewBox:[vx,vy,vw,vh],
      minW: imgW*0.08, minH: imgH*0.08,
      maxW: vw, maxH: vh,
      panning:false, dragCandidate:false, dragged:false, start:{x:0,y:0}, last:{x:0,y:0},
      pointers:new Map(), initialPinchDist:0, initialViewBox:null,
      enabled:true
    };
    const apply=()=> svgEl.setAttribute('viewBox', nav.viewBox.join(' '));
    const atFull=()=> (Math.abs(nav.viewBox[2]-nav.maxW)<0.5 && Math.abs(nav.viewBox[3]-nav.maxH)<0.5);

    function setTouchMode(){
      if(!nav.enabled){ svgEl.style.touchAction='none'; return; }
      if(atFull() && nav.pointers.size <= 1){ svgEl.style.touchAction = 'pan-y'; }
      else{ svgEl.style.touchAction = 'none'; }
    }
    function guardEnabled(handler){ return function(e){ if(!nav.enabled) return; return handler(e); }; }

    svgEl.addEventListener('wheel', guardEnabled((e)=>{
      let [vx,vy,vw,vh]=nav.viewBox;
      const full = atFull();
      if(full && e.deltaY > 0){ return; }
      e.preventDefault();
      const scale=(e.deltaY<0?0.9:1.1);
      const mx=e.offsetX/svgEl.clientWidth, my=e.offsetY/svgEl.clientHeight;
      let nw=clamp(vw*scale, nav.minW, nav.maxW);
      let nh=clamp(vh*scale, nav.minH, nav.maxH);
      const nx=clamp(vx+(vw-nw)*mx, 0, imgW-nw);
      const ny=clamp(vy+(vh-nh)*my, 0, imgH-nh);
      nav.viewBox=[nx,ny,nw,nh]; apply(); setTouchMode();
    }), {passive:false});

    svgEl.addEventListener('pointerup', guardEnabled((e)=>{
      if(nav.panning){ if(e.cancelable) e.preventDefault(); }
    }), {passive:false, capture:true});

    svgEl.addEventListener('pointerdown', guardEnabled((e)=>{
      nav.pointers.set(e.pointerId, {x: e.clientX, y: e.clientY});
      nav.dragCandidate = true; nav.dragged = false;
      nav.start = {x: e.clientX, y: e.clientY};
      nav.last  = {x: e.clientX, y: e.clientY};
      if(nav.pointers.size===2){
        const pts=[...nav.pointers.values()];
        nav.initialPinchDist = Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y);
        nav.initialViewBox = nav.viewBox.slice();
      }
      svgEl.style.cursor='grabbing'; setTouchMode();
    }));

    svgEl.addEventListener('pointermove', guardEnabled((e)=>{
      if(!nav.pointers.has(e.pointerId)) return;
      nav.pointers.set(e.pointerId, {x: e.clientX, y: e.clientY});
      if(nav.pointers.size===2){
        const pts=[...nav.pointers.values()];
        const dist = Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y);
        if(nav.initialPinchDist>0){
          const scale = nav.initialPinchDist / dist;
          const [vx,vy,vw,vh] = nav.initialViewBox;
          let nw = clamp(vw * scale, nav.minW, nav.maxW);
          let nh = clamp(vh * scale, nav.minH, nav.maxH);
          const mx = ((pts[0].x + pts[1].x)/2) / svgEl.clientWidth;
          const my = ((pts[0].y + pts[1].y)/2) / svgEl.clientHeight;
          let nx = clamp(vx + (vw - nw)*mx, 0, imgW - nw);
          let ny = clamp(vy + (vh - nh)*my, 0, imgH - nh);
          nav.viewBox=[nx,ny,nw,nh]; apply(); setTouchMode();
        }
        return;
      }
      if(nav.dragCandidate){
        const dx0=e.clientX - nav.start.x, dy0=e.clientY - nav.start.y;
        if(dx0*dx0 + dy0*dy0 > 16){
          nav.panning=true; nav.dragCandidate=false; nav.dragged=true;
          try{ svgEl.setPointerCapture(e.pointerId); }catch{}
        }
      }
      if(!nav.panning) return;
      let [vx,vy,vw,vh]=nav.viewBox;
      const dx=(e.clientX-nav.last.x)*(vw/svgEl.clientWidth);
      const dy=(e.clientY-nav.last.y)*(vh/svgEl.clientHeight);
      vx=clamp(vx-dx, 0, imgW - vw);
      vy=clamp(vy-dy, 0, imgH - vh);
      nav.viewBox=[vx,vy,vw,vh]; nav.last={x: e.clientX, y: e.clientY}; apply();
    }));

    function endPointer(e){
      nav.pointers.delete(e.pointerId);
      nav.panning=false; nav.dragCandidate=false; nav.dragged=false;
      nav.initialPinchDist=0; nav.initialViewBox=null;
      svgEl.style.cursor='grab'; setTouchMode();
      try{ svgEl.releasePointerCapture(e.pointerId); }catch{}
    }
    svgEl.addEventListener('pointerup', guardEnabled(endPointer));
    svgEl.addEventListener('pointercancel', guardEnabled(endPointer));
    svgEl.addEventListener('lostpointercapture', ()=> setTouchMode());

    window.addEventListener('resize', ()=>{
      const rect = svgEl.getBoundingClientRect();
      const centerX = nav.viewBox[0] + nav.viewBox[2]/2;
      const centerY = nav.viewBox[1] + nav.viewBox[3]/2;
      const {vw, vh} = computeCoverCrop(imgW, imgH, rect.width, rect.height);
      nav.maxW = vw; nav.maxH = vh;
      let nw = clamp(nav.viewBox[2], nav.minW, nav.maxW);
      let nh = clamp(nav.viewBox[3], nav.minH, nav.maxH);
      let nx = clamp(centerX - nw/2, 0, imgW - nw);
      let ny = clamp(centerY - nh/2, 0, imgH - nh);
      nav.viewBox=[nx,ny,nw,nh]; apply(); setTouchMode();
    });

    return {
      enable(on){ nav.enabled = on; setTouchMode(); },
      reset:()=>{
        const rect = svgEl.getBoundingClientRect();
        const {vw, vh} = computeCoverCrop(imgW, imgH, rect.width, rect.height);
        const vx = (imgW - vw) / 2;
        const vy = (imgH - vh) / 2;
        nav.maxW = vw; nav.maxH = vh;
        nav.viewBox=[vx,vy,vw,vh]; apply(); setTouchMode();
      }
    };
  }

  let navigatorApi=null;
  init().catch(console.error);

  async function init(){
    const loaded = await loadData();
    const saved = loadLocal();
    state = Object.assign({}, loaded, saved);

    renderMultiline(primerIntro, state.primerIntro || '');
    renderMultiline(primerDetails, state.primerDetails || '');
    renderMultiline(islandLore, state.islandLore || islandLore.textContent || '');

    const wSize = state.mapSize || {w:4080,h:3072};
    mapImage.setAttribute('href', state.mapSrc || DEFAULT_WORLD_MAP);
    mapImage.setAttribute('width', wSize.w); mapImage.setAttribute('height', wSize.h);
    svgWorld.setAttribute('viewBox', `0 0 ${wSize.w} ${wSize.h}`);

    islandImg.src = state.campaignMapSrc || state.campaignMap || DEFAULT_ISLAND_MAP;
    islandImg.alt = "Signika island map";

    renderFeatures();
    navigatorApi = makeBoundedNavigator(svgWorld, wSize.w, wSize.h);
    bindGM();
    bindTooltipDismiss();

    loader.style.display='none';
  }

  async function loadData(){
    try{
      const res = await fetch(JSON_PATH, {cache:'no-store'});
      if(!res.ok) throw 0;
      const text = await res.text();
      let data;
      try{ data = JSON.parse(text);}catch(e){ console.error('JSON parse error:', e, text); throw e; }
      return {
        mapSrc: data.mapImage || data.mapSrc || DEFAULT_WORLD_MAP,
        mapSize: data.mapSize || {w:4080,h:3072},
        campaignMapSrc: data.campaignMap || data.campaignMapSrc || DEFAULT_ISLAND_MAP,
        campaignMapSize: data.campaignMapSize || {w:1024,h:1024},
        features: data.features || [],
        primerIntro: data.primerIntro || '',
        primerDetails: data.primerDetails || '',
        islandLore: data.islandLore || ''
      };
    }catch(e){
      console.error('Falling back to defaults due to load error:', e);
      return { mapSrc: DEFAULT_WORLD_MAP, mapSize:{w:4080,h:3072}, campaignMapSrc: DEFAULT_ISLAND_MAP,
               campaignMapSize:{w:1024,h:1024}, features:[], primerIntro:'', primerDetails:'', islandLore:'' };
    }
  }

  function loadLocal(){ try{ return JSON.parse(localStorage.getItem(LS_KEY) || '{}'); }catch(e){ return {}; } }
  function saveLocal(){
    const payload={
      mapSrc: state.mapSrc, mapSize: state.mapSize,
      campaignMapSrc: state.campaignMapSrc, campaignMapSize: state.campaignMapSize,
      features: state.features,
      primerIntro: primerIntro.textContent.trim(),
      primerDetails: primerDetails.textContent.trim(),
      islandLore: islandLore.textContent.trim()
    };
    localStorage.setItem(LS_KEY, JSON.stringify(payload));
  }

  function renderFeatures(){
    gRegions.innerHTML=''; gPoints.innerHTML='';
    const feats = (state.features||[]);

    feats.filter(f=>f.type==='region').forEach(f=>{
      const g=elNS('g'); g.classList.add('feature','region'); g.dataset.id=f.id||'';
      const color=f.color||'#8ad9ff';
      const neon = blendHex(color, '#e7d9b7', 0.80);

      (f.shapes||[]).forEach(shape=>{
        const d = roundedPolygonPath(shape, 10);
        const fill=elNS('path');
        fill.setAttribute('d', d);
        fill.setAttribute('class','fill');
        fill.setAttribute('fill', color);
        fill.setAttribute('fill-opacity', '0.31');
        fill.setAttribute('stroke','none');
        fill.style.filter='url(#fuzzyEdge)';
        fill.addEventListener('click', (e)=> showTooltipFor(f, e));
        g.appendChild(fill);

        const glow=elNS('path'); glow.setAttribute('d', d); glow.setAttribute('class','ol-glow'); glow.setAttribute('stroke', neon);
        const mid =elNS('path'); mid .setAttribute('d', d); mid .setAttribute('class','ol-mid');  mid .setAttribute('stroke', neon);
        const core=elNS('path'); core.setAttribute('d', d); core.setAttribute('class','ol-core');
        g.appendChild(glow); g.appendChild(mid); g.appendChild(core);
      });
      g.addEventListener('mouseenter', ()=> g.classList.add('hover'));
      g.addEventListener('mouseleave', ()=> g.classList.remove('hover'));
      g.addEventListener('click', (e)=> showTooltipFor(f,e));
      gRegions.appendChild(g);
    });

    feats.filter(f=>f.type==='point').forEach(f=>{
      const g=elNS('g'); g.classList.add('feature','point'); g.dataset.id=f.id||'';
      const c=elNS('circle'); c.setAttribute('cx', f.x); c.setAttribute('cy', f.y); c.setAttribute('r', 18);
      const t=elNS('text'); t.setAttribute('x', f.x+30); t.setAttribute('y', f.y-30); t.classList.add('label'); t.textContent=f.name||'';
      const open=(e)=> showTooltipFor(f,e);
      c.addEventListener('click', open); t.addEventListener('click', open);
      g.appendChild(c); g.appendChild(t); gPoints.appendChild(g);
    });
  }

  function setSelectedRegionById(id){
    document.querySelectorAll('#regions .feature.region').forEach(el=>{
      if(el.dataset.id === id){ el.classList.add('selected'); }
      else{ el.classList.remove('selected'); }
    });
  }

  function bindTooltipDismiss(){
    ttClose.addEventListener('click', ()=> tooltip.classList.remove('open'));
    svgWorld.addEventListener('click', (e)=>{
      const isFeature = !!e.target.closest('.feature');
      const isMobile = window.matchMedia('(max-width: 760px)').matches;
      if(!isFeature){
        if(!isMobile && tooltip.classList.contains('open')) tooltip.classList.remove('open');
        document.querySelectorAll('.feature.region.selected').forEach(el=>el.classList.remove('selected'));
      }
    });
  }

  function sizeAndPositionTooltip(evt){
    const wrapRect = mapWrap.getBoundingClientRect();
    // Hard clamp tooltip size to wrapper
    const padding = 8;
    const maxW = Math.max(240, wrapRect.width - padding*2);
    const maxH = Math.max(180, wrapRect.height - padding*2);
    tooltip.style.maxWidth = Math.min(420, maxW) + 'px';
    tooltip.style.maxHeight = maxH + 'px';
    // Measure after forcing layout
    const ttRect = tooltip.getBoundingClientRect();
    // Preferred position: near cursor
    const cx = (evt && evt.clientX) || (wrapRect.left + wrapRect.width/2);
    const cy = (evt && evt.clientY) || (wrapRect.top + wrapRect.height/2);
    let x = cx - wrapRect.left + 12;
    let y = cy - wrapRect.top + 12;
    // Clamp to stay fully visible
    const maxX = wrapRect.width - ttRect.width - padding;
    const maxY = wrapRect.height - ttRect.height - padding;
    x = Math.max(padding, Math.min(maxX, x));
    y = Math.max(padding, Math.min(maxY, y));
    tooltip.style.left = x + 'px';
    tooltip.style.top  = y + 'px';
  }

  function showTooltipFor(f, evt){
    if(!f) return;
    const isMobile = window.matchMedia('(max-width: 760px)').matches;
    const name = f.name || '—';
    const desc = f.desc || '';
    const src = f.img || f.image || f.imageUrl || null;
    if(f.type === 'region'){ setSelectedRegionById(f.id || ''); }

    if(isMobile){
      loreTitle.textContent = name;
      renderMultiline(loreBody, desc);
      if(src){ loreImg.src=src; loreImg.alt=name+' image'; loreMedia.style.display='block'; }
      else { loreImg.removeAttribute('src'); loreMedia.style.display='none'; }
      tooltip.classList.remove('open');
    }else{
      ttTitle.textContent = name;
      ttBody.innerHTML = desc ? escapeHTML(desc).replace(/
/g,'<br>') : '—';
      if(src){
        ttImg.onload = ()=>{ sizeAndPositionTooltip(evt); };
        ttImg.src = src; ttImg.alt = name+' image'; ttMedia.style.display='block';
      } else {
        ttImg.removeAttribute('src'); ttMedia.style.display='none';
      }
      tooltip.classList.add('open');
      // Position after content update; do double-pass to be safe
      requestAnimationFrame(()=>{ sizeAndPositionTooltip(evt); });
      requestAnimationFrame(()=>{ sizeAndPositionTooltip(evt); });
      // Also mirror to side panel
      loreTitle.textContent = name;
      renderMultiline(loreBody, desc);
      loreImg.removeAttribute('src'); loreMedia.style.display='none';
    }
  }

  function bindGM(){
    const editables=[primerIntro, primerDetails, islandLore];
    let gmOn=false, saveTimer=0;
    const editor={ selectedId:null, mode:'idle', curShape:null, busy(){ return this.mode!=='idle'; } };

    function setEditable(on){
      editables.forEach(el=> el.setAttribute('contenteditable', on ? 'true' : 'false'));
      document.body.classList.toggle('gm-on', on);
      gmBtn.classList.toggle('on', on);
      gmBtn.textContent = on ? 'GM: ON' : 'GM';
      gmBar.style.display = on ? 'flex' : 'none';
      navigatorApi && navigatorApi.enable(on ? !editor.busy() : true);
      drawOverlay();
    }
    const scheduleSave=()=>{ clearTimeout(saveTimer); saveTimer=setTimeout(saveLocal, 400); };
    editables.forEach(el=>{ el.addEventListener('input', scheduleSave); el.addEventListener('blur', saveLocal); });
    gmBtn.addEventListener('click', ()=>{ gmOn=!gmOn; setEditable(gmOn); if(gmOn){ scheduleSave(); } });

    const regionSelect = document.getElementById('regionSelect');
    const regionName   = document.getElementById('regionName');
    const regionColor  = document.getElementById('regionColor');
    const addShapeBtn  = document.getElementById('addShapeBtn');
    const finishShapeBtn= document.getElementById('finishShapeBtn');
    const addVertexModeBtn= document.getElementById('addVertexModeBtn');
    const delVertexModeBtn= document.getElementById('delVertexModeBtn');
    const newRegionBtn = document.getElementById('newRegionBtn');
    const saveJsonBtn  = document.getElementById('saveJsonBtn');

    function refreshRegionSelect(){
      const regions = (state.features||[]).filter(f=>f.type==='region');
      regionSelect.innerHTML='';
      regions.forEach(r=>{
        const opt=document.createElement('option');
        opt.value=r.id; opt.textContent=r.name || r.id;
        regionSelect.appendChild(opt);
      });
      if(!editor.selectedId && regions[0]) editor.selectedId = regions[0].id;
      regionSelect.value = editor.selectedId || '';
      updateRegionFields();
    }
    function updateRegionFields(){
      const r = getSelectedRegion();
      regionName.value = r ? (r.name||'') : '';
      regionColor.value = r ? (r.color||'#8ad9ff') : '#8ad9ff';
      drawOverlay();
    }
    function getSelectedRegion(){
      return (state.features||[]).find(f=>f.type==='region' && f.id===editor.selectedId) || null;
    }

    regionSelect.addEventListener('change', ()=>{ editor.selectedId=regionSelect.value; updateRegionFields(); });
    regionName.addEventListener('input', ()=>{ const r=getSelectedRegion(); if(!r) return; r.name=regionName.value; renderFeatures(); refreshRegionSelect(); saveLocal();});
    regionColor.addEventListener('input', ()=>{ const r=getSelectedRegion(); if(!r) return; r.color=regionColor.value; renderFeatures(); drawOverlay(); saveLocal(); });

    newRegionBtn.addEventListener('click', ()=>{
      const id = 'region-'+Date.now().toString(36);
      const r = { id, type:'region', name:'New Region', color:'#8ad9ff', desc:'', shapes:[] };
      state.features = state.features || [];
      state.features.push(r);
      editor.selectedId = id;
      renderFeatures(); refreshRegionSelect(); saveLocal();
    });

    addShapeBtn.addEventListener('click', ()=>{
      const r=getSelectedRegion(); if(!r){ alert('Create or select a region first.'); return; }
      editor.mode='adding';
      editor.curShape={ points:[], regionRef:r, shapeIndex:r.shapes.length };
      r.shapes.push(editor.curShape.points);
      navigatorApi && navigatorApi.enable(false);
      drawOverlay();
    });

    finishShapeBtn.addEventListener('click', ()=>{
      if(editor.mode!=='adding'){ editor.mode='idle'; editor.curShape=null; drawOverlay(); navigatorApi && navigatorApi.enable(true); return; }
      const pts = editor.curShape.points;
      if(!pts || pts.length<3){ alert('Need at least 3 points.'); return; }
      editor.mode='idle'; editor.curShape=null; renderFeatures(); drawOverlay(); saveLocal(); navigatorApi && navigatorApi.enable(true);
    });

    addVertexModeBtn.addEventListener('click', ()=>{ editor.mode = editor.mode==='addVertex' ? 'idle' : 'addVertex'; drawOverlay(); navigatorApi && navigatorApi.enable(editor.mode==='idle'); });
    delVertexModeBtn.addEventListener('click', ()=>{ editor.mode = editor.mode==='delVertex' ? 'idle' : 'delVertex'; drawOverlay(); navigatorApi && navigatorApi.enable(editor.mode==='idle'); });

    saveJsonBtn.addEventListener('click', ()=>{
      const exportData={
        mapImage: state.mapSrc || DEFAULT_WORLD_MAP,
        mapSize: state.mapSize || {w:4080,h:3072},
        campaignMap: state.campaignMapSrc || DEFAULT_ISLAND_MAP,
        campaignMapSize: state.campaignMapSize || {w:1024,h:1024},
        primerIntro: primerIntro.innerText.trim(),
        primerDetails: primerDetails.innerText.trim(),
        islandLore: islandLore.innerText.trim(),
        features: state.features || []
      };
      const blob = new Blob([JSON.stringify(exportData, null, 2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'world-data.json';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
    });

    function drawOverlay(){
      gmOverlay.innerHTML='';
      if(!document.body.classList.contains('gm-on')) return;
      const r = getSelectedRegion(); if(!r) return;

      (r.shapes||[]).forEach((shape, si)=>{
        const path=elNS('path'); path.setAttribute('class','shape-path');
        path.setAttribute('d', roundedPolygonPath(shape, 0));
        gmOverlay.appendChild(path);

        for(let i=0;i<shape.length;i++){
          const a=shape[i], b=shape[(i+1)%shape.length];
          const edge=elNS('line');
          edge.setAttribute('class','edge');
          edge.setAttribute('x1', a.x); edge.setAttribute('y1', a.y);
          edge.setAttribute('x2', b.x); edge.setAttribute('y2', b.y);
          edge.addEventListener('click', (e)=>{
            if(editor.mode!=='addVertex') return;
            e.stopPropagation();
            const p = clientToSvg(e.clientX, e.clientY);
            shape.splice(i+1, 0, p);
            drawOverlay(); renderFeatures(); saveLocal();
          });
          gmOverlay.appendChild(edge);
        }

        shape.forEach((pt, idx)=>{
          const h=elNS('circle'); h.setAttribute('class','handle'); h.setAttribute('r', 8);
          h.setAttribute('cx', pt.x); h.setAttribute('cy', pt.y);
          if(editor.mode==='delVertex'){ h.classList.add('del'); }
          let dragging=false, id=null;
          h.addEventListener('pointerdown', (e)=>{
            if(editor.mode==='delVertex'){
              e.stopPropagation(); if(shape.length>3){ shape.splice(idx,1); drawOverlay(); renderFeatures(); saveLocal(); }
              return;
            }
            e.preventDefault(); dragging=true; id=e.pointerId; h.setPointerCapture(id); h.classList.add('drag');
          });
          h.addEventListener('pointermove', (e)=>{
            if(!dragging) return;
            const p = clientToSvg(e.clientX, e.clientY);
            pt.x=p.x; pt.y=p.y;
            h.setAttribute('cx', pt.x); h.setAttribute('cy', pt.y);
            path.setAttribute('d', roundedPolygonPath(shape, 0));
            renderFeatures();
          });
          h.addEventListener('pointerup', ()=>{ if(!dragging) return; dragging=false; h.classList.remove('drag'); saveLocal(); });
          gmOverlay.appendChild(h);
        });
      });

      if(editor.mode==='adding' && editor.curShape){
        const pts = editor.curShape.points;
        const tempPath=elNS('path'); tempPath.setAttribute('class','shape-path');
        tempPath.setAttribute('d', pts.length? roundedPolygonPath(pts, 0) : '');
        gmOverlay.appendChild(tempPath);

        svgWorld.onpointerdown = (e)=>{ const p = clientToSvg(e.clientX, e.clientY); pts.push(p); drawOverlay(); };
        svgWorld.ondblclick = (e)=>{ finishShapeBtn.click(); };
      }else{
        svgWorld.onpointerdown = null; svgWorld.ondblclick=null;
      }
    }

    refreshRegionSelect();
    drawOverlay();
  }

})();</script>
</body>
</html>
