<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The World of Draelon – Campaign Primer (v16 · tiny map loader)</title>
  <style>
    :root{ --bg:#0b0d12; --panel:#141821; --panel-2:#1b2130; --accent:#c6f06e; --accent-2:#8ad9ff; --text:#e8ecf3; --muted:#9aa3b2; --shadow:0 10px 30px rgba(0,0,0,.45); --radius:14px }
    html,body{height:100%}
    *{-webkit-tap-highlight-color:transparent}
    body{margin:0;background:radial-gradient(1200px 800px at 70% 10%, #151926, #0b0d12 60%, #07090e);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}

    /* Top bar */
    header.site{display:flex;align-items:center;justify-content:space-between;padding:14px 18px;background:#141821;border-bottom:1px solid #232a3a;box-shadow:0 8px 24px rgba(0,0,0,.4);position:sticky;top:0;z-index:50}
    header.site h1{margin:0;font-size:22px;color:var(--accent)}
    header.site .tag{font-size:12px;color:#cfd7eb}

    /* Primer blocks */
    .primer{max-width:1000px;margin:16px auto 8px;padding:0 16px}
    .primer .card{background:var(--panel);border:1px solid #232a3a;border-radius:16px;box-shadow:var(--shadow);padding:16px}
    .primer h2{margin:0 0 8px;color:#bfe27a}
    .primer .md{color:#dbe2f6;line-height:1.6}

    /* Map container */
    .wrap {
  position: relative;
  height: 74vh;
  min-height: 440px;
  margin: 12px auto 16px;
  max-width: 1200px;
  border-radius: var(--radius);
  background: var(--panel);
  box-shadow: var(--shadow);
  overflow: hidden;
  z-index: 0; /* ⬅️ make sure map sits *under* tooltip */
}
    svg#world{width:100%;height:100%;display:block;background:#0d111a;touch-action:none;user-select:none}

    /* Tiny top-left loader */
    .map-loading{position:absolute;left:10px;top:10px;z-index:11;background:rgba(9,13,20,.85);border:1px solid #2b354a;border-radius:10px;padding:6px 8px;font-size:12px;color:#cbd5e1;opacity:1;transform:translateY(0);transition:opacity .2s ease, transform .2s ease}
    .map-loading.hide{opacity:0;transform:translateY(-4px);pointer-events:none}

    /* Controls */
    .zoombar{position:absolute;left:12px;top:12px;display:flex;flex-direction:column;gap:8px;z-index:8}
    .btn{background:#101522;color:#e6edf8;border:1px solid #33405a;border-radius:10px;padding:8px 12px;cursor:pointer}
    .zoombar .btn{width:38px;height:38px;display:flex;align-items:center;justify-content:center}
    .gm-btn{position:absolute;top:12px;right:12px;z-index:9;background:var(--panel-2);border:1px solid #2b354a;border-radius:999px;padding:8px 12px;font-weight:700}
    .hint{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,.35);border:1px solid #2b354a;border-radius:8px;padding:6px 8px;font-size:12px;color:#cbd5e1;z-index:8}

    /* CMS */
    .cms{position:absolute;top:56px;right:12px;width:min(520px,calc(100% - 24px));max-height:calc(100% - 68px);background:var(--panel-2);border:1px solid #2b354a;border-radius:14px;box-shadow:var(--shadow);display:none;z-index:9;overflow:hidden}
    .cms.open{display:flex;flex-direction:column}
    .cms header{display:flex;gap:8px;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid #2b354a;flex-wrap:wrap}
    .cms header h2{font-size:14px;margin:0}
    .cms .cms-body{padding:12px;overflow:auto;display:grid;gap:10px}
    .row{display:grid;gap:6px}
    .row label{font-size:12px;color:#cbd5e1}
    .row input[type="text"],.row textarea,.row select,.row input[type="color"]{width:100%;box-sizing:border-box;background:#101522;color:#e6edf8;border:1px solid #33405a;border-radius:10px;padding:10px 12px}
    .row textarea{min-height:100px;resize:vertical}
    .list{border-top:1px dashed #33405a;padding-top:8px;display:grid;gap:6px}
    .item{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:8px 10px;background:#0f1420;border:1px solid #2b354a;border-radius:10px}
    .chip{font-size:11px;padding:2px 6px;border-radius:999px;background:#1a2335;border:1px solid #2b354a;color:#b9c4da}
    .btn.danger{border-color:#503038;background:#2a0f14;color:#ffb4bf}

    /* Map features */
    .feature{cursor:pointer;outline:none}
    .feature.region path{stroke-width:0;fill-opacity:.31;transition:fill-opacity .12s linear;filter:url(#fuzzyEdge)}
    .feature.region.hover path{fill-opacity:.36}
    .feature.region.selected path{fill-opacity:.44}
    .feature.point circle{stroke:#141821;stroke-width:3;fill:var(--accent)}
    .feature.point .label{font-size:36px;fill:#eaf3ff;pointer-events:none;paint-order:stroke;stroke:#0b0e15;stroke-width:6px}

    /* Edit handles */
    .edit-handle{fill:#fff;stroke:#000;stroke-width:1.5;cursor:grab}
    .edge-handle{fill:#8ad9ff;stroke:#0b0e15;stroke-width:1.2;opacity:.95;cursor:copy}

    /* Tooltip lore */
    .tooltip {
  position: absolute;
  z-index: 20; /* ⬅️ ensure tooltip is above everything */
  min-width: 220px;
  max-width: min(420px,78vw);
  background: rgba(15,20,32,.94);
  border: 1px solid #2b354a;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,.5);
  padding: 10px 12px;
  opacity: 0;
  transform: translateY(6px);
  transition: opacity .15s ease, transform .15s ease;
  pointer-events: auto; /* ⬅️ allow the close button to work */
}
    .tooltip.show{opacity:1;transform:translateY(0)}
    .tooltip h3{margin:0 16px 6px 0;font-size:16px;color:#d7def0}
    .tooltip .md{margin:0;color:#dbe2f6;line-height:1.45}
    .tooltip .close{position:absolute;right:8px;top:6px;background:transparent;border:0;color:#cbd5e1;cursor:pointer;font-size:16px}

    @media (max-width:900px){ .wrap{height:70vh} }
  </style>
</head>
<body>
  <header class="site">
    <h1>The World of Draelon</h1>
    <span class="tag">Campaign Primer</span>
  </header>

  <!-- World intro (GM-editable markdown) -->
  <section class="primer" id="introSection">
    <div class="card">
      <h2>World Introduction</h2>
      <div class="md" id="introRender">Loading…</div>
    </div>
  </section>

  <div class="wrap">
    <!-- tiny non-blocking loader -->
    <div class="map-loading" id="mapLoading">Loading map…</div>

    <div class="zoombar">
      <button class="btn" id="zoomIn" title="Zoom in">＋</button>
      <button class="btn" id="zoomOut" title="Zoom out">－</button>
      <button class="btn" id="zoomReset" title="Reset view">⤾</button>
    </div>
    <div class="hint" id="hint">Drag/Pan · Scroll/Pinch to zoom</div>

    <button class="gm-btn" id="gmBtn" title="GM Mode">GM</button>

    <div class="cms" id="cms">
      <header>
        <h2>GM Tools</h2>
        <div class="toolbar" style="display:flex;gap:8px;flex-wrap:wrap">
          <button class="btn" id="toolSelect" type="button">Select</button>
          <button class="btn" id="toolAddPoint" type="button">Add Point</button>
          <button class="btn" id="toolAddRegion" type="button">New Region</button>
          <button class="btn" id="toolAddShape" type="button">Add Shape to Region</button>
          <button class="btn" id="toolExport" type="button">Export</button>
          <label class="btn" for="importFile" style="cursor:pointer;">Import</label>
          <input id="importFile" type="file" accept="application/json" style="display:none;" />
        </div>
      </header>
      <div class="cms-body">
        <div class="row">
          <label for="mapPath">Map Image Path (root-relative, e.g. <code>/map/world-map.jpg</code>)</label>
          <input type="text" id="mapPath" placeholder="/map/world-map.jpg" />
          <button class="btn" id="reloadMap" type="button">Reload Map</button>
        </div>
        <div class="row">
          <label>Selected Feature</label>
          <select id="featurePicker"></select>
        </div>
        <div class="row">
          <label for="featName">Name (auto-saves)</label>
          <input id="featName" type="text" placeholder="e.g., Signika" />
        </div>
        <div class="row">
          <label for="featDesc">Lore / Notes (auto-saves)</label>
          <textarea id="featDesc" placeholder="Write lore or notes..."></textarea>
        </div>
        <div class="row" id="rowColor" style="display:none;">
          <label for="featColor">Region Colour (live)</label>
          <input id="featColor" type="color" value="#8ad9ff" />
        </div>
        <div class="row" id="pointDanger" style="display:none;">
          <button class="btn danger" id="deletePoint" type="button">Delete Point</button>
        </div>
        <div class="row" id="shapeManager" style="display:none;">
          <label>Shapes in Region</label>
          <div id="shapeList" class="list"></div>
        </div>
        <div class="list" id="featureList"></div>

        <div class="row">
          <label for="introEdit">World Introduction (Markdown)</label>
          <textarea id="introEdit" placeholder="# Welcome to Draelon
Write your intro here…"></textarea>
        </div>
        <div class="row">
          <label for="campaignEdit">Campaign Primer (Markdown)</label>
          <textarea id="campaignEdit" placeholder="# Signika Awakens
Write your campaign primer here…"></textarea>
        </div>
      </div>
    </div>

    <div class="tooltip" id="tooltip" role="dialog" aria-live="polite" aria-hidden="true">
      <button class="close" id="tipClose" aria-label="Close">✕</button>
      <h3 id="tipTitle">Lore</h3>
      <div class="md" id="tipBody">Tap a location to view details.</div>
    </div>

    <svg id="world" viewBox="0 0 1000 600" preserveAspectRatio="xMidYMid meet" aria-label="Interactive world map">
      <defs>
        <filter id="fuzzyEdge" x="-4%" y="-4%" width="108%" height="108%">
          <feGaussianBlur in="SourceAlpha" stdDeviation="2.5" result="blur" />
          <feComposite in="SourceGraphic" in2="blur" operator="in" />
        </filter>
      </defs>
      <image id="mapImage" href="" x="0" y="0" width="1000" height="600" />
      <g id="regions"></g>
      <g id="points"></g>
      <g id="editHandles"></g>
    </svg>
  </div>

  <!-- Campaign primer (GM-editable markdown) -->
  <section class="primer" id="campaignSection">
    <div class="card">
      <h2>Campaign Primer</h2>
      <div class="md" id="campaignRender">Loading…</div>
    </div>
  </section>

<script>
(async function(){
  const STORAGE_KEY = 'draelon.world.v16';
  const DEFAULT_REGION_COLOR = '#8ad9ff';

  // Elements
  const svg = document.getElementById('world');
  const gRegions = document.getElementById('regions');
  const gPoints = document.getElementById('points');
  const editHandles = document.getElementById('editHandles');
  const mapImage = document.getElementById('mapImage');
  const hint = document.getElementById('hint');
  const tooltip = document.getElementById('tooltip');
  const tipTitle = document.getElementById('tipTitle');
  const tipBody = document.getElementById('tipBody');
  const tipClose = document.getElementById('tipClose');
  const introRender = document.getElementById('introRender');
  const campaignRender = document.getElementById('campaignRender');
  const mapLoading = document.getElementById('mapLoading');

  // CMS
  const gmBtn = document.getElementById('gmBtn');
  const cms = document.getElementById('cms');
  const toolSelect = document.getElementById('toolSelect');
  const toolAddPoint = document.getElementById('toolAddPoint');
  const toolAddRegion = document.getElementById('toolAddRegion');
  const toolAddShape = document.getElementById('toolAddShape');
  const exportBtn = document.getElementById('toolExport');
  const importFile = document.getElementById('importFile');
  const featurePicker = document.getElementById('featurePicker');
  const featName = document.getElementById('featName');
  const featDesc = document.getElementById('featDesc');
  const featColor = document.getElementById('featColor');
  const rowColor = document.getElementById('rowColor');
  const pointDanger = document.getElementById('pointDanger');
  const deletePointBtn = document.getElementById('deletePoint');
  const shapeManager = document.getElementById('shapeManager');
  const shapeList = document.getElementById('shapeList');
  const featureList = document.getElementById('featureList');
  const introEdit = document.getElementById('introEdit');
  const campaignEdit = document.getElementById('campaignEdit');
  const mapPath = document.getElementById('mapPath');
  const reloadMapBtn = document.getElementById('reloadMap');

  // Load external JSON (root-relative)
  let state = await loadExternalJSON('/world-data.json') || loadLocal() || defaultState();
  state.primer = state.primer || { intro: defaultIntro(), campaign: defaultCampaign() };

  // Map & viewbox
  let mapW = state.mapSize?.w || 1000;
  let mapH = state.mapSize?.h || 600;

  // initial zoom/pan (~70% scale, panned upward a bit)
  let view = { x: 0, y: Math.round(mapH*0.10), w: Math.round(mapW*0.70), h: Math.round(mapH*0.70) };
  applyView();

  // Runtime state
  let gmOpen=false, currentTool='select', buildingRegion=null, buildingShapeTargetRegionId=null, selectedId=state.features[0]?.id||null, hoveredId=null, isDraggingFeature=false;
  let activePointers = new Map();
  let isPanning=false; let panStart=null;

  // Primer initial render
  introEdit.value = state.primer.intro;
  campaignEdit.value = state.primer.campaign;
  introRender.innerHTML = mdToHtml(state.primer.intro);
  campaignRender.innerHTML = mdToHtml(state.primer.campaign);

  // Map meta + tiny loader behavior
  applyMapMetaFromState();
  // If we have a path, show loader badge until load/error; else hide immediately
  if (!state.mapImage) hideMapLoaderSoon();
  else await setMapImagePath(state.mapImage);

  // Render initial
  render();

  // Tooltip helpers
  function showTooltip(f, clientX, clientY){
    tipTitle.textContent = f.name || 'Lore';
    tipBody.innerHTML = mdToHtml(f.desc || '');
    requestAnimationFrame(()=>{
      let left = clientX + 12;
      let top = clientY - 12;
      const maxLeft = window.innerWidth - 20 - tooltip.offsetWidth;
      const maxTop = window.innerHeight - 20 - tooltip.offsetHeight;
      tooltip.style.left = Math.min(left, Math.max(12, maxLeft)) + 'px';
      tooltip.style.top = Math.min(top, Math.max(12, maxTop)) + 'px';
      tooltip.style.display = 'block';
      tooltip.classList.add('show');
      tooltip.setAttribute('aria-hidden','false');
    });
  }
  function hideTooltip(){ tooltip.classList.remove('show'); tooltip.style.display = 'none'; tooltip.setAttribute('aria-hidden','true'); }
  tipClose.addEventListener('click', hideTooltip);
  document.addEventListener('click', (e)=>{ if(!tooltip.contains(e.target) && e.target.closest('svg')==null) hideTooltip(); }, true);

  // Interactions
  function attachRegionGroupHandlers(g, f){
    const isCoarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
    g.addEventListener('pointerenter', (e)=>{ if(isCoarse) return; hoveredId=f.id; selectedId=f.id; updateStates(); });
    g.addEventListener('pointerleave', ()=>{ if(isCoarse) return; hoveredId=null; updateStates(); });
    g.addEventListener('click', (e)=>{ selectedId=f.id; updateStates(); showTooltip(f, e.clientX, e.clientY); });
  }
  function attachPointHandlers(node,f){
    node.addEventListener('click', (e)=>{ selectedId=f.id; updateStates(); showTooltip(f, e.clientX, e.clientY); if(gmOpen) selectFeature(f.id); });
    node.addEventListener('dblclick', (e)=>{ if(!gmOpen) return; e.stopPropagation(); if(confirm(`Delete point "${f.name}"?`)){ state.features = state.features.filter(x=>x.id!==f.id); if(selectedId===f.id) selectedId=null; render(); hideTooltip(); } });
    node.addEventListener('pointerdown', (e)=>{ if(!gmOpen) return; if(currentTool==='select' || currentTool==='add-point'){ selectFeature(f.id); startDragPoint(e, f); isDraggingFeature=true; } });
  }

  function updateStates(){ gRegions.querySelectorAll('.feature.region').forEach(g=>{ const id=g.getAttribute('data-id'); g.classList.toggle('hover', id===hoveredId); g.classList.toggle('selected', id===selectedId); }); }

  // Tools
  function setTool(t){ currentTool = t; [toolSelect, toolAddPoint, toolAddRegion, toolAddShape].forEach(btn=> btn && btn.classList.remove('primary')); if(t==='select') toolSelect?.classList.add('primary'); if(t==='add-point') toolAddPoint?.classList.add('primary'); if(t==='add-region') toolAddRegion?.classList.add('primary'); if(t==='add-shape') toolAddShape?.classList.add('primary'); }
  setTool('select');
  gmBtn?.addEventListener('click', ()=>{ gmOpen=!gmOpen; cms?.classList.toggle('open', gmOpen); gmBtn.textContent = gmOpen? 'GM ✓' : 'GM'; updateHint(); render(); });
  function updateHint(){ if(!hint) return; hint.textContent = gmOpen ? 'Drag/Pan · Pinch/Scroll to zoom · Shift-drag moves shape · Ctrl/⌘-drag moves region · Alt-click vertex deletes · Click mid-dot inserts · Double-click finishes new region' : 'Drag/Pan · Pinch/Scroll to zoom'; }
  updateHint();

  // Add via clicks
  svg.addEventListener('click', (e)=>{
    if(!gmOpen) return; const pt = svgPoint(e);
    if(currentTool==='add-point'){
      const f = { id:uid(), type:'point', name:'New Point', desc:'', x:pt.x, y:pt.y };
      state.features.push(f); render(); selectFeature(f.id); showTooltip(f, e.clientX, e.clientY); return;
    }
    if(currentTool==='add-region'){
      if(!buildingRegion){
        const r = { id:uid(), type:'region', name:'New Region', color: DEFAULT_REGION_COLOR, desc:'', shapes:[[ {x:pt.x,y:pt.y} ]] };
        state.features.push(r); buildingRegion = r; selectedId=r.id; render(); selectFeature(r.id);
      } else {
        const shape = buildingRegion.shapes[ buildingRegion.shapes.length-1 ];
        shape.push({x:pt.x,y:pt.y}); render(); selectFeature(buildingRegion.id);
      }
      return;
    }
    if(currentTool==='add-shape' && buildingRegion && buildingShapeTargetRegionId){
      const r = featureById(buildingShapeTargetRegionId); if(!r) return;
      if(!buildingRegion.shape.length){
        const s = 24; const half = s/2;
        const square = [ {x:pt.x-half, y:pt.y-half}, {x:pt.x+half, y:pt.y-half}, {x:pt.x+half, y:pt.y+half}, {x:pt.x-half, y:pt.y+half} ];
        r.shapes.push(square);
        buildingRegion = null; buildingShapeTargetRegionId = null; setTool('select');
        render(); selectFeature(r.id);
      }
      return;
    }
  });

  svg.addEventListener('dblclick', ()=>{
    if(!gmOpen) return;
    if(currentTool==='add-region'){
      const r = buildingRegion; if(!r) return;
      const shape = r.shapes[r.shapes.length-1];
      if(shape.length<3){ alert('Need at least 3 points for a shape.'); return; }
      buildingRegion = null; setTool('select'); render();
    }
  });

  // Drag helpers
  function startDragPoint(e, f){
    e.preventDefault();
    const start = svgPoint(e);
    const offset = { x: f.x - start.x, y: f.y - start.y };
    const move=(ev)=>{ const p=svgPoint(ev); f.x=clamp(p.x + offset.x,0,mapW); f.y=clamp(p.y + offset.y,0,mapH); render(); selectFeature(f.id,false); };
    const up=()=>{ off(move,up); isDraggingFeature=false; saveLocal(); };
    on(move,up);
  }
  function startDragShapeMove(e, f, sIdx){
    const p=svgPoint(e);
    const offset={x:p.x,y:p.y};
    const move=(ev)=>{ const q=svgPoint(ev); const dx=q.x-offset.x, dy=q.y-offset.y; f.shapes[sIdx]=f.shapes[sIdx].map(pt=>({x:clamp(pt.x+dx,0,mapW),y:clamp(pt.y+dy,0,mapH)})); offset.x=q.x; offset.y=q.y; render(); selectFeature(f.id,false); };
    const up=()=>{ off(move,up); isDraggingFeature=false; saveLocal(); };
    on(move,up);
  }
  function startDragRegionMove(e, f){
    const p=svgPoint(e);
    const offset={x:p.x,y:p.y};
    const move=(ev)=>{ const q=svgPoint(ev); const dx=q.x-offset.x, dy=q.y-offset.y; f.shapes=f.shapes.map(shape=> shape.map(pt=>({x:clamp(pt.x+dx,0,mapW),y:clamp(pt.y+dy,0,mapH)})) ); offset.x=q.x; offset.y=q.y; render(); selectFeature(f.id,false); };
    const up=()=>{ off(move,up); isDraggingFeature=false; saveLocal(); };
    on(move,up);
  }
  function on(move,up){ window.addEventListener('pointermove',move); window.addEventListener('pointerup',up, { once:true }); }
  function off(move,up){ window.removeEventListener('pointermove',move); }

  // Pan & Zoom (mouse + touch pinch)
  const zoomIn = document.getElementById('zoomIn');
  const zoomOut = document.getElementById('zoomOut');
  const zoomReset = document.getElementById('zoomReset');

  function applyView(){ svg.setAttribute('viewBox', `${view.x} ${view.y} ${view.w} ${view.h}`); }
  function zoom(factor, center){
    const cx=center?.x ?? (view.x+view.w/2);
    const cy=center?.y ?? (view.y+view.h/2);
    const nw=clamp(view.w*factor, 200, mapW);
    const nh=clamp(view.h*factor, 120, mapH);
    view.x=clamp(cx-nw/2,0,Math.max(0,mapW-nw));
    view.y=clamp(cy-nh/2,0,Math.max(0,mapH-nh));
    view.w=nw; view.h=nh; applyView();
  }
  zoomIn?.addEventListener('click', ()=> zoom(0.8));
  zoomOut?.addEventListener('click', ()=> zoom(1.25));
  zoomReset?.addEventListener('click', ()=>{ view={x:0,y:0,w:mapW,h:mapH}; applyView(); });

  // Pointer handling to allow panning even when starting on regions
  svg.addEventListener('pointerdown', (e)=>{
    svg.setPointerCapture(e.pointerId);
    activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if(activePointers.size===1){ isPanning=true; panStart={sx:e.clientX, sy:e.clientY, vx:view.x, vy:view.y}; }
  }, true);
  svg.addEventListener('pointermove', (e)=>{
    if(activePointers.has(e.pointerId)) activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if(activePointers.size===2){
      // Natural pinch: spread -> zoom in, pinch -> zoom out
      const pts=[...activePointers.values()];
      const d0=Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
      if(panStart && typeof panStart.d === 'number'){
        const d1 = d0;
        const factor = panStart.d>0 ? panStart.d/d1 : 1; // if fingers move apart => factor<1 => zoom in
        const center = clientToSvg({x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2});
        zoom(factor, center);
        panStart.d = d1;
      } else {
        panStart = panStart || {}; panStart.d = d0;
      }
      return;
    }
    if(isPanning && activePointers.size===1){
      const dx=(e.clientX-panStart.sx)*(view.w/svg.getBoundingClientRect().width);
      const dy=(e.clientY-panStart.sy)*(view.h/svg.getBoundingClientRect().height);
      view.x=clamp(panStart.vx-dx,0,Math.max(0,mapW-view.w));
      view.y=clamp(panStart.vy-dy,0,Math.max(0,mapH-view.h));
      applyView();
    }
  });
  svg.addEventListener('pointerup', (e)=>{
    activePointers.delete(e.pointerId);
    if(activePointers.size===0){ isPanning=false; panStart=null; }
  });
  svg.addEventListener('wheel', (e)=>{ e.preventDefault(); const pt=svgPoint(e); const factor = e.deltaY>0 ? 1.15 : 0.85; zoom(factor, pt); }, {passive:false});

  // CMS interactions
  function render(){
    gRegions.innerHTML=''; gPoints.innerHTML=''; editHandles.innerHTML='';

    // regions
    state.features.filter(f=>f.type==='region').forEach(f=>{
      const g = elNS('g'); g.classList.add('feature','region'); g.setAttribute('tabindex','0'); g.setAttribute('data-id', f.id);
      const color = f.color || DEFAULT_REGION_COLOR;
      (f.shapes||[]).forEach((shape, sIdx)=>{
        if(!Array.isArray(shape) || shape.length<3) return;
        const path = elNS('path');
        path.setAttribute('d', roundedPolygonPath(shape, 10));
        path.setAttribute('fill', color);
        path.setAttribute('stroke', 'none');
        path.style.filter='url(#fuzzyEdge)';
        path.addEventListener('pointerdown', (e)=>{
          if(!(gmOpen && currentTool==='select')) return;
          const moveWhole = e.ctrlKey||e.metaKey;
          const moveShape = e.shiftKey;
          if(moveWhole){ startDragRegionMove(e, f); isDraggingFeature=true; e.stopPropagation(); }
          else if(moveShape){ startDragShapeMove(e, f, sIdx); isDraggingFeature=true; e.stopPropagation(); }
        });
        g.appendChild(path);
      });
      attachRegionGroupHandlers(g, f);
      gRegions.appendChild(g);

      // edit handles
      if(selectedId===f.id && gmOpen){
        (f.shapes||[]).forEach((shape, sIdx)=>{
          shape.forEach((p,idx)=>{
            const h = elNS('circle'); h.setAttribute('cx', p.x); h.setAttribute('cy', p.y); h.setAttribute('r', 6); h.classList.add('edit-handle');
            h.addEventListener('pointerdown', (e)=> startDragVertex(e, f, sIdx, idx));
            h.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); if(e.altKey){ deleteVertex(f, sIdx, idx); render(); } });
            editHandles.appendChild(h);
          });
          for(let i=0;i<shape.length;i++){
            const a=shape[i], b=shape[(i+1)%shape.length];
            const mx=(a.x+b.x)/2, my=(a.y+b.y)/2; const m = elNS('circle');
            m.setAttribute('cx', mx); m.setAttribute('cy', my); m.setAttribute('r', 6); m.classList.add('edge-handle');
            m.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); insertVertexAtEdge(f, sIdx, i, {x:mx, y:my}); render(); });
            editHandles.appendChild(m);
          }
        });
      }
    });

    // points
    state.features.filter(f=>f.type==='point').forEach(f=>{
      const g = elNS('g'); g.classList.add('feature','point'); g.setAttribute('data-id', f.id);
      const c = elNS('circle'); c.setAttribute('cx', f.x); c.setAttribute('cy', f.y); c.setAttribute('r', 18);
      const label = elNS('text'); label.setAttribute('x', f.x + 30); label.setAttribute('y', f.y - 30); label.classList.add('label'); label.textContent = f.name;
      g.appendChild(c); g.appendChild(label); attachPointHandlers(g, f); gPoints.appendChild(g);
    });

    refreshPicker(); refreshList(); updateStates(); refreshShapeListUI(); updatePointDanger(); saveLocal();
  }

  function refreshPicker(){ const id=selectedId; featurePicker.innerHTML = state.features.map(f=>`<option value="${f.id}">${escapeHTML(f.name)} (${f.type})</option>`).join(''); if(id){ const idx=state.features.findIndex(f=>f.id===id); featurePicker.selectedIndex = idx>=0 ? idx : 0; } onPickerChange(); }
  function refreshList(){ featureList.innerHTML=''; state.features.forEach(f=>{ const div=document.createElement('div'); div.className='item'; const tint = f.type==='region' ? `<span class="chip" style="background:${f.color||DEFAULT_REGION_COLOR};color:#0b0e15;border:none">&nbsp;&nbsp;</span>` : ''; div.innerHTML=`<div class="meta">${tint}<span class="chip">${f.type}</span><strong>${escapeHTML(f.name)}</strong></div><div class="toolbar" style="display:flex;gap:8px"><button class="btn" data-act="edit" type="button">Edit</button></div>`; div.querySelector('[data-act="edit"]').addEventListener('click', ()=>{ selectFeature(f.id); }); featureList.appendChild(div); }); }
  function onPickerChange(){ const id=featurePicker.value; if(!id) return; const f=state.features.find(x=>x.id===id); if(!f) return; selectedId=id; featName.value=f.name||''; featDesc.value=f.desc||''; if(f.type==='region'){ rowColor.style.display='grid'; featColor.value=(f.color||DEFAULT_REGION_COLOR); shapeManager.style.display='grid'; pointDanger.style.display='none'; } else { rowColor.style.display='none'; shapeManager.style.display='none'; pointDanger.style.display='grid'; } updateStates(); refreshShapeListUI(); }
  featurePicker.addEventListener('change', onPickerChange);
  function selectFeature(id, updatePicker=true){ selectedId=id; if(updatePicker) refreshPicker(); onPickerChange(); }
  function updatePointDanger(){ const f=state.features.find(x=>x.id===selectedId); pointDanger.style.display = (f && f.type==='point' && gmOpen) ? 'grid' : 'none'; }

  // Auto-save
  featName.addEventListener('input', ()=>{ const f=featureById(selectedId); if(!f) return; f.name=featName.value; refreshPicker(); refreshList(); saveLocal(); render(); });
  featDesc.addEventListener('input', ()=>{ const f=featureById(selectedId); if(!f) return; f.desc=featDesc.value; saveLocal(); });
  introEdit.addEventListener('input', ()=>{ state.primer.intro = introEdit.value; introRender.innerHTML = mdToHtml(state.primer.intro); saveLocal(); });
  campaignEdit.addEventListener('input', ()=>{ state.primer.campaign = campaignEdit.value; campaignRender.innerHTML = mdToHtml(state.primer.campaign); saveLocal(); });

  // Color updates
  let colorRAF = 0;
  featColor.addEventListener('input', ()=>{ const f = featureById(selectedId); if(!f || f.type!=='region') return; f.color = featColor.value || DEFAULT_REGION_COLOR; if(colorRAF) cancelAnimationFrame(colorRAF); colorRAF = requestAnimationFrame(()=>{ updateRegionColorDOM(f); saveLocal(); }); });
  function updateRegionColorDOM(f){ const g = gRegions.querySelector(`.feature.region[data-id="${CSS.escape(f.id)}"]`); if(!g) { render(); return; } g.querySelectorAll('path').forEach(p=> p.setAttribute('fill', f.color || DEFAULT_REGION_COLOR)); }

  deletePointBtn.addEventListener('click', ()=>{ const f=featureById(selectedId); if(!f || f.type!=='point') return; if(!confirm(`Delete point "${f.name}"?`)) return; state.features = state.features.filter(x=>x.id!==f.id); selectedId=null; render(); hideTooltip(); });

  // Reload map path
  reloadMapBtn.addEventListener('click', async ()=>{
    const path = (mapPath.value||'').trim();
    state.mapImage = path || '';
    showMapLoader();
    await setMapImagePath(path);
    saveLocal();
  });

  // Export / Import include primer + path (no base64)
  exportBtn.addEventListener('click', ()=>{
    try{
      const data = JSON.stringify({ mapImage: state.mapImage||'', mapSize: state.mapSize, features: state.features, primer: state.primer }, null, 2);
      const blob = new Blob([data], {type:'application/json'});
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = 'draelon-world.json';
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
    }catch(err){ alert('Export failed: ' + (err?.message||err)); }
  });

  importFile.addEventListener('change', (e)=>{
    const file=e.target.files?.[0]; if(!file) return;
    const reader=new FileReader();
    reader.onload=async ()=>{
      try{
        const obj=JSON.parse(reader.result);
        if(obj.features) state.features=obj.features.map(f=> migrateFeature(f));
        if(obj.mapSize){ state.mapSize=obj.mapSize; mapW=state.mapSize.w; mapH=state.mapSize.h; mapImage.setAttribute('width',mapW); mapImage.setAttribute('height',mapH); svg.setAttribute('viewBox',`0 0 ${mapW} ${mapH}`); view={x:0,y:0,w:mapW,h:mapH}; }
        state.mapImage = obj.mapImage || '';
        if(obj.primer) state.primer = { intro: obj.primer.intro||'', campaign: obj.primer.campaign||'' };
        introEdit.value = state.primer.intro; campaignEdit.value = state.primer.campaign;
        introRender.innerHTML = mdToHtml(state.primer.intro); campaignRender.innerHTML = mdToHtml(state.primer.campaign);
        mapPath.value = state.mapImage || '';
        showMapLoader();
        await setMapImagePath(state.mapImage);
        applyView(); render(); saveLocal();
      }catch(err){ alert('Invalid JSON'); }
    };
    reader.readAsText(file);
  });

  // ----- Map image helpers (path-only) -------------------------------------
  function applyMapMetaFromState(){
    state.mapSize = state.mapSize || {w:1000,h:600};
    mapW = state.mapSize.w; mapH = state.mapSize.h;
    mapImage.setAttribute('width', mapW);
    mapImage.setAttribute('height', mapH);
    svg.setAttribute('viewBox',`0 0 ${mapW} ${mapH}`);
    mapPath.value = state.mapImage || '';
  }

  async function setMapImagePath(path){
    // Always clear and rebind events to detect load/end
    mapImage.removeAttribute('href');
    // Prepare one-off listeners
    const done = ()=> hideMapLoaderSoon();
    mapImage.addEventListener('load', done, { once:true });
    mapImage.addEventListener('error', done, { once:true });

    if(!path){
      // No image path -> hide loader and bail
      hideMapLoaderSoon();
      return;
    }
    // Setting href triggers load lifecycle on <image>
    mapImage.setAttribute('href', path);
    // Failsafe: hide after 2.5s regardless (non-blocking)
    setTimeout(hideMapLoaderSoon, 2500);
  }

  function showMapLoader(){ mapLoading.classList.remove('hide'); }
  function hideMapLoaderSoon(){ mapLoading.classList.add('hide'); }

  // ----- Data helpers ------------------------------------------------------
  function featureById(id){ return state.features.find(x=>x.id===id); }
  function uid(){ return Math.random().toString(36).slice(2) + Date.now().toString(36); }
  function saveLocal(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch(e){} }
  function loadLocal(){ try{ const s = localStorage.getItem(STORAGE_KEY); return s? migrate(JSON.parse(s)): null; }catch(e){ return null; } }
  function defaultIntro(){ return `# Draelon at a Glance

*From the gilded courts of Oscana to the spellbound towers of Eturia, and the iron hosts of Athium—Draelon is a world of divided crowns and converging destinies.*

- **Oscana** – feudal realms, old blood, new money.
- **Athium** – an empire tempered for conquest.
- **Eturia** – a magocracy where scholarship is sovereignty.
- **Signika** – a northern island long ignored… until now.`; }
  function defaultCampaign(){ return `# Signika Awakens

Monsters once thought myth now tread the forests of **Signika**—some wreathed in strange light, others touched by unheard-of magics. Guilds arrive in force:
- **Legio Xernacus** (Athium-backed)
- **Wyrm’s Hoard** (Oscanan mercenaries)
- **Eturian expeditions** (scholars with sharp minds and sharper wards)

Your choices will decide whose banners take root and which secrets stay buried.`; }
  function defaultState(){ return migrate({ mapImage:'', mapSize:{w:1000,h:600}, primer:{ intro: defaultIntro(), campaign: defaultCampaign() }, features:[ { id: uid(), type:'region', name:'Oscana', color: DEFAULT_REGION_COLOR, desc:'Western continent of divided kingdoms and feudal intrigue.', shapes:[[{x:195,y:140},{x:415,y:150},{x:430,y:250},{x:300,y:270},{x:200,y:230}]] }, { id: uid(), type:'region', name:'Athium', color: DEFAULT_REGION_COLOR, desc:'Imperial power in the southeast; militarised and ambitious.', shapes:[[{x:720,y:180},{x:900,y:190},{x:870,y:430},{x:690,y:410}]] }, { id: uid(), type:'region', name:'Eturia', color: DEFAULT_REGION_COLOR, desc:'Magocracy to the south—politics by spellbook.', shapes:[[{x:480,y:450},{x:580,y:520},{x:520,y:580},{x:450,y:520}], [{x:600,y:480},{x:640,y:500},{x:620,y:530}]] }, { id: uid(), type:'point', name:'Signika', desc:'A wild northern island. Greywake port at the south. Recently crawling with strange, empowered monsters.', x:560, y:160 } ] }); }
  async function loadExternalJSON(path){ try{ const res = await fetch(path, {cache:'no-store'}); if(!res.ok) return null; const data = await res.json(); return migrate(data); }catch(e){ return null; } }
  function migrate(s){ if(!s) return null; if(!s.mapSize){ s.mapSize={w:1000,h:600}; } if(!s.primer){ s.primer = { intro: defaultIntro(), campaign: defaultCampaign() }; } if(Array.isArray(s.features)) s.features = s.features.map(f=> migrateFeature(f)); return s; }
  function migrateFeature(f){ if(f.type==='region'){ if(!f.shapes && f.points){ f.shapes=[f.points]; delete f.points; } f.color = f.color || DEFAULT_REGION_COLOR; return f; } else { return f; } }
  function svgPoint(evt){ const rect=svg.getBoundingClientRect(); const x = view.x + (evt.clientX - rect.left) * (view.w / rect.width); const y = view.y + (evt.clientY - rect.top) * (view.h / rect.height); return {x,y}; }
  function clientToSvg(pt){ const rect=svg.getBoundingClientRect(); const x = view.x + (pt.x - rect.left) * (view.w / rect.width); const y = view.y + (pt.y - rect.top) * (view.h / rect.height); return {x,y}; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function elNS(name){ return document.createElementNS('http://www.w3.org/2000/svg', name); }
  function escapeHTML(s){ return (s||'').replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }

  // Minimal Markdown → HTML
  function mdToHtml(md){
    md = (md||'');
    md = md.replace(/[&<>]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
    md = md.replace(/^######\s?(.*)$/gm,'<h6>$1</h6>')
           .replace(/^#####\s?(.*)$/gm,'<h5>$1</h5>')
           .replace(/^####\s?(.*)$/gm,'<h4>$1</h4>')
           .replace(/^###\s?(.*)$/gm,'<h3>$1</h3>')
           .replace(/^##\s?(.*)$/gm,'<h2>$1</h2>')
           .replace(/^#\s?(.*)$/gm,'<h1>$1</h1>');
    md = md.replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>')
           .replace(/\*(.*?)\*/g,'<em>$1</em>')
           .replace(/__(.*?)__/g,'<strong>$1</strong>')
           .replace(/_(.*?)_/g,'<em>$1</em>');
    md = md.replace(/^(?:- |\* )(.*)$/gm,'<li>$1</li>');
    md = md.replace(/(<li>.*<\/li>\n?)+/g, m=> `<ul>${m}</ul>`);
    md = md.split(/\n\n+/).map(p=>`<p>${p.replace(/\n/g,'<br/>')}</p>`).join('');
    return md;
  }

  // --- geometry helpers ----------------------------------------------------
  function roundedPolygonPath(points, radius){
    const n=points.length; if(n<3) return '';
    const r = Math.max(0, radius|0);
    function lerp(a,b,t){ return {x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t}; }
    let d='';
    for(let i=0;i<n;i++){
      const p0=points[(i-1+n)%n], p1=points[i], p2=points[(i+1)%n];
      const rr = Math.min(r, dist(p1,p0)/2, dist(p1,p2)/2);
      const pA = lerp(p1, p0, rr/dist(p1,p0));
      const pB = lerp(p1, p2, rr/dist(p1,p2));
      if(i===0){ d += `M ${pA.x} ${pA.y} `; }
      d += `L ${pA.x} ${pA.y} Q ${p1.x} ${p1.y} ${pB.x} ${pB.y} `;
    }
    d += 'Z';
    return d;
  }
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

  // Edit vertex helpers
  function startDragVertex(e, f, sIdx, idx){
    e.preventDefault(); e.stopPropagation();
    const start = svgPoint(e);
    const startPt = { x: f.shapes[sIdx][idx].x, y: f.shapes[sIdx][idx].y };
    const offset = { x: startPt.x - start.x, y: startPt.y - start.y };
    const move=(ev)=>{ const p=svgPoint(ev); f.shapes[sIdx][idx]={x:clamp(p.x + offset.x,0,mapW),y:clamp(p.y + offset.y,0,mapH)}; render(); selectFeature(f.id,false); };
    const up=()=>{ off(move,up); isDraggingFeature=false; saveLocal(); };
    on(move,up);
  }
  function insertVertexAtEdge(f,sIdx,i,p){ f.shapes[sIdx].splice(i+1,0,{x:p.x,y:p.y}); }
  function deleteVertex(f,sIdx,idx){ if(f.shapes[sIdx].length<=3){ deleteShape(f, sIdx); return; } f.shapes[sIdx].splice(idx,1); }
  function deleteShape(f, sIdx){ f.shapes.splice(sIdx,1); }

  // Shapes UI list
  function refreshShapeListUI(){
    const f = featureById(selectedId);
    shapeList.innerHTML='';
    if(!f || f.type!=='region'){ shapeManager.style.display='none'; return; }
    shapeManager.style.display='grid';
    f.shapes.forEach((shape, idx)=>{
      const div=document.createElement('div'); div.className='item';
      div.innerHTML = `<div class="meta"><span class="chip">Shape ${idx+1}</span><span class="muted">${shape.length} pts</span></div>`+
                      `<div class="toolbar" style="display:flex;gap:8px"><button class="btn danger" data-del>Delete Shape</button></div>`;
      div.querySelector('[data-del]').addEventListener('click', ()=>{
        if(!confirm('Delete this shape from the region?')) return;
        deleteShape(f, idx); render(); selectFeature(f.id);
      });
      shapeList.appendChild(div);
    });
  }

  // ----- tiny map loader utils -----
  function hideMapLoaderSoon(){ mapLoading.classList.add('hide'); }
  function showMapLoader(){ mapLoading.classList.remove('hide'); }

  // ----- end helpers -----

})();
</script>
</body>
</html>

