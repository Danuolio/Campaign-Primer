<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The World of Draelon – Campaign Primer (Weathered Scroll v29)</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Uncial+Antiqua&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#f3ecd6; --ink:#2b2415; --ink-soft:#4a4028;
      --accent:#b6862f; --accent-2:#3a845a; --emboss:#fff8e7;
      --shadow-color: rgba(34, 20, 9, .35);
      --panel: rgba(255,250,230,.85);
      --panel-2: rgba(255,245,215,.92);
      --radius:14px; --shadow:0 12px 40px var(--shadow-color);
    }
    html,body{height:100%}
    body{
      margin:0; color:var(--ink); font-family:'Cinzel', serif;
      background:
        radial-gradient(1200px 900px at 70% 5%, rgba(255,255,240,.9), rgba(243,236,214,1) 40%, #efe3c3 70%, #e9d9b2 100%),
        radial-gradient(600px 400px at 20% 10%, rgba(255,255,255,.35), rgba(0,0,0,0) 70%),
        radial-gradient(800px 600px at 80% 20%, rgba(255,255,255,.25), rgba(0,0,0,0) 70%),
        repeating-linear-gradient( 0deg, rgba(0,0,0,.03), rgba(0,0,0,.03) 2px, rgba(0,0,0,0) 3px, rgba(0,0,0,0) 6px );
      overflow-x:hidden;
    }
    body::before{content:'';position:fixed;inset:0;pointer-events:none;
      background:radial-gradient(circle at 30% 40%, rgba(0,0,0,.025), transparent 60%), radial-gradient(circle at 70% 60%, rgba(0,0,0,.02), transparent 60%);
      mix-blend-mode:multiply; animation:drift 40s linear infinite; opacity:.8; z-index:-1}
    @keyframes drift{0%{transform:translate3d(0,0,0)}50%{transform:translate3d(20px,10px,0)}100%{transform:translate3d(0,0,0)}}
    h1,h2,h3,h4{font-family:'Uncial Antiqua', cursive; letter-spacing:.5px; color:var(--ink); text-shadow:0 1px 0 var(--emboss)}
    .primer{margin:16px auto; max-width:1200px; padding:20px 24px; border-radius:var(--radius);
      background:linear-gradient(180deg, rgba(255,253,245,.9), rgba(255,248,229,.88)), linear-gradient(180deg, rgba(255,255,255,.7), rgba(255,255,255,0));
      border:1px solid rgba(103,77,28,.25); box-shadow:var(--shadow); position:relative}
    .primer::before{content:'';position:absolute;inset:0;border-radius:var(--radius);box-shadow:inset 0 0 80px rgba(0,0,0,.08);pointer-events:none}
    .primer::after{content:'';position:absolute;inset:0;border-radius:var(--radius);border:1px solid rgba(255,255,255,.6);mix-blend-mode:overlay;opacity:.5;pointer-events:none}
    .primer h2{margin:0 0 8px;font-size:26px}
    .primer p,.lore-body{line-height:1.55;margin:0;color:var(--ink-soft)}
    .app{position:relative;display:grid;grid-template-columns:minmax(380px,1fr) minmax(320px,420px);gap:16px;max-width:1200px;margin:0 auto;padding:0 8px}
    .map-wrap{position:sticky;top:12px;min-height:60vh;max-height:78vh;border-radius:var(--radius);
      background:linear-gradient(180deg, rgba(255,253,245,.92), rgba(255,248,229,.90));border:1px solid rgba(103,77,28,.25);box-shadow:var(--shadow);
      overflow:hidden;transition:transform .45s ease, box-shadow .45s ease}
    .map-wrap:hover{transform:translateY(-2px); box-shadow:0 18px 60px var(--shadow-color)}
    svg#world{width:100%;height:100%;display:block;touch-action:none;background:
      radial-gradient(800px 500px at 50% 10%, rgba(255,255,255,.6), rgba(255,255,255,0)),
      linear-gradient(180deg, rgba(255,253,245,.7), rgba(255,248,229,.6))}
    .side{border-radius:var(--radius);background:linear-gradient(180deg, rgba(255,253,245,.92), rgba(255,248,229,.90));
      border:1px solid rgba(103,77,28,.25);box-shadow:var(--shadow);overflow:hidden;display:flex;flex-direction:column}
    .side header{padding:14px 16px;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid rgba(103,77,28,.25);
      background:linear-gradient(180deg, rgba(255,255,255,.8), rgba(255,255,255,.5))}
    .side .content{padding:16px;overflow:auto}
    .lore-title{font-weight:700;margin:0 0 8px;font-size:18px}
    .muted{color:#6b5c3a;font-size:12px}
    .loader{position:absolute;left:10px;top:10px;display:flex;align-items:center;gap:8px;background:rgba(255,248,229,.9);border:1px solid rgba(103,77,28,.25);border-radius:10px;padding:6px 10px;z-index:20;backdrop-filter:blur(2px)}
    .spinner{width:14px;height:14px;border-radius:50%;border:2px solid rgba(160,120,60,.3); border-top-color:var(--accent); animation:spin .8s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .gm-btn{position:absolute;top:12px;right:12px;z-index:10;background:linear-gradient(180deg, #ffefd0, #ffe5b5);color:var(--ink);border:1px solid rgba(103,77,28,.35);border-radius:999px;padding:8px 12px;font-weight:700;cursor:pointer;box-shadow:var(--shadow)}
    .gm-btn:hover{filter:brightness(1.03)}
    .gm-modal{position:absolute;inset:0;display:none;align-items:center;justify-content:center;z-index:20}
    .gm-modal.open{display:flex}
    .gm-modal-backdrop{position:absolute;inset:0;background:rgba(0,0,0,.25);backdrop-filter:blur(2px)}
    .gm-modal-card{position:relative;width:min(92%,360px);background:var(--panel-2);border:1px solid rgba(103,77,28,.35);border-radius:14px;box-shadow:var(--shadow);padding:16px;z-index:1}
    .gm-modal-card h3{margin:0 0 8px;font-size:16px}
    .gm-modal-card input{width:100%;background:#fff6df;color:var(--ink);border:1px solid rgba(103,77,28,.35);border-radius:10px;padding:10px 12px;box-sizing:border-box;margin:8px 0 10px}
    .btn{background:#fff4d6;color:var(--ink);border:1px solid rgba(103,77,28,.35);border-radius:10px;padding:8px 12px;cursor:pointer}
    .btn.primary{background:linear-gradient(180deg,#ffe39a,#ffd369);box-shadow:inset 0 1px 0 #fff8e7}
    .btn.danger{border-color:#7a2f2c;background:#ffe2df;color:#7a2f2c}
    .cms{position:absolute;top:56px;right:12px;width:min(560px,calc(100% - 24px));max-height:calc(100% - 68px);background:var(--panel-2);border:1px solid rgba(103,77,28,.35);border-radius:14px;box-shadow:var(--shadow);display:none;z-index:9;overflow:hidden}
    .cms.open{display:flex;flex-direction:column}
    .cms header{display:flex;gap:8px;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid rgba(103,77,28,.35);flex-wrap:wrap;background:linear-gradient(180deg,rgba(255,255,255,.7),rgba(255,255,255,.4))}
    .cms header h2{font-size:14px;margin:0}
    .cms .cms-body{padding:12px;overflow:auto;display:grid;gap:10px}
    .row{display:grid;gap:6px}
    .row label{font-size:12px;color:#6b5c3a}
    .row input[type="text"],.row textarea,.row select,.row input[type="color"]{width:100%;box-sizing:border-box;background:#fff6df;color:var(--ink);border:1px solid rgba(103,77,28,.35);border-radius:10px;padding:10px 12px}
    .row textarea{min-height:100px;resize:vertical}
    .list{border-top:1px dashed rgba(103,77,28,.35);padding-top:8px;display:grid;gap:6px}
    .item{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:8px 10px;background:#fff8e7;border:1px solid rgba(103,77,28,.35);border-radius:10px}
    .item .meta{display:flex;gap:10px;align-items:center}
    .chip{font-size:11px;padding:2px 6px;border-radius:999px;background:#fff1c4;border:1px solid rgba(103,77,28,.35);color:#5a4925}
    .feature{cursor:pointer}
    .feature.point circle{stroke:#f2e6c4;stroke-width:3;fill:#d49e3c}
    .feature.point .label{font-size:36px;fill:#4a4028;pointer-events:none;paint-order:stroke;stroke:#fff1d0;stroke-width:6px;stroke-linejoin:round}
    .feature.region path{stroke-width:0;transition:fill-opacity .12s linear}
    .feature.region.hover path{fill-opacity:.35}
    .feature.region.selected path{fill-opacity:.42}
    .edit-handle{fill:#fff;stroke:#000;stroke-width:1.5;cursor:grab}
    .edit-handle:active{cursor:grabbing}
    .edge-handle{fill:#3a845a;stroke:#ffffff;stroke-width:1;opacity:.95;cursor:copy}
    .zoombar{position:absolute;left:12px;top:48px;display:flex;flex-direction:column;gap:8px;z-index:8}
    .zoombar .btn{width:38px;height:38px;border-radius:10px;display:flex;align-items:center;justify-content:center}
    .hint{position:absolute;left:12px;bottom:12px;background:rgba(255,250,230,.95);border:1px solid rgba(103,77,28,.35);border-radius:8px;padding:6px 8px;font-size:12px;color:#5a4925;z-index:8}
    .hint kbd{background:#fff1c4;border:1px solid rgba(103,77,28,.35);padding:0 6px;border-radius:6px;font-size:11px}
    .tooltip{position:absolute;min-width:240px;max-width:360px;background:rgba(255,248,229,.98);border:1px solid rgba(103,77,28,.35);border-radius:12px;box-shadow:var(--shadow);z-index:15;display:none;pointer-events:auto}
    .tooltip.open{display:block}
    .tooltip header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid rgba(103,77,28,.25)}
    .tooltip header h3{margin:0;font-size:16px;color:#5a4925}
    .tooltip .close{background:transparent;border:0;color:#6b5c3a;cursor:pointer;font-size:18px}
    .tooltip .body{padding:10px 12px;color:#4a4028;line-height:1.5}
    .reveal{opacity:0;transform:translateY(14px);transition:opacity .8s ease, transform .8s ease}
    .reveal.visible{opacity:1;transform:translateY(0)}
    @media (max-width:900px){.app{grid-template-columns:1fr}.map-wrap{min-height:50vh;max-height:70vh}}
  </style>
</head>
<body>
  <div class="primer reveal" id="primerTop">
    <h2>The World of Draelon</h2>
    <div id="primerIntro">This is your editable campaign introduction. Enable GM mode to edit this text. Players can scroll the map, tap regions, and read tooltips.</div>
  </div>

  <div class="app">
    <div class="map-wrap reveal" id="mapWrap">
      <div class="loader" id="loader" aria-live="polite"><div class="spinner"></div><span id="loaderText">Loading world…</span></div>
      <div class="zoombar" aria-hidden="false">
        <button class="btn" id="zoomIn" title="Zoom in" type="button">＋</button>
        <button class="btn" id="zoomOut" title="Zoom out" type="button">－</button>
        <button class="btn" id="zoomReset" title="Reset view" type="button">⤾</button>
      </div>
      <div class="hint" id="hint">Drag map to pan · Scroll/Pinch to zoom · Click a region/point for details</div>

      <button class="gm-btn" id="gmBtn" title="GM Mode" type="button">GM</button>
      <div class="gm-modal" id="gmModal" aria-hidden="true">
        <div class="gm-modal-backdrop" id="gmBackdrop"></div>
        <div class="gm-modal-card">
          <h3>Enter GM Passcode</h3>
          <input id="gmPass" type="password" placeholder="Passcode" autocomplete="off" />
          <div class="toolbar" style="display:flex;gap:8px;justify-content:flex-end">
            <button class="btn" id="gmCancel" type="button">Cancel</button>
            <button class="btn primary" id="gmSubmit" type="button">Unlock</button>
          </div>
          <p class="muted" id="gmError" style="display:none;margin-top:8px;color:#7a2f2c">Wrong code. Try again.</p>
        </div>
      </div>

      <div class="cms" id="cms">
        <header>
          <h2>GM Tools</h2>
          <div class="toolbar" style="display:flex;gap:8px;flex-wrap:wrap">
            <button class="btn" id="toolSelect" type="button">Select</button>
            <button class="btn" id="toolAddPoint" type="button">Add Point</button>
            <button class="btn" id="toolAddRegion" type="button">New Region</button>
            <button class="btn" id="toolAddShape" type="button">Add Shape to Region</button>
            <button class="btn" id="toolExport" type="button">Export</button>
            <label class="btn" for="importFile" style="cursor:pointer;">Import</label>
            <input id="importFile" type="file" accept="application/json" style="display:none;" />
          </div>
        </header>
        <div class="cms-body">
          <div class="row">
            <label>Primer Intro (top) – auto-saves</label>
            <textarea id="primerIntroEdit" placeholder="Edit the top primer text..."></textarea>
          </div>
          <div class="row">
            <label>Primer Details (bottom) – auto-saves</label>
            <textarea id="primerDetailsEdit" placeholder="Edit the bottom primer details..."></textarea>
          </div>
          <div class="row">
            <label>Map Image <span class="muted">(Upload to replace – CSP-safe)</span></label>
            <input type="file" id="mapFile" accept="image/*" />
          </div>
          <div class="row">
            <label>Selected Feature</label>
            <select id="featurePicker"></select>
          </div>
          <div class="row">
            <label for="featName">Name (auto-saves)</label>
            <input id="featName" type="text" placeholder="e.g., Signika" />
          </div>
          <div class="row">
            <label for="featDesc">Lore / Notes (auto-saves)</label>
            <textarea id="featDesc" placeholder="Write lore or notes..."></textarea>
          </div>
          <div class="row" id="rowColor" style="display:none;">
            <label for="featColor">Region Colour (live)</label>
            <input id="featColor" type="color" value="#c99a3b" />
          </div>
          <div class="row" id="shapeManager" style="display:none;">
            <label>Shapes in Region</label>
            <div id="shapeList" class="list"></div>
          </div>
          <div class="list" id="featureList"></div>
        </div>
      </div>

      <div class="tooltip" id="tooltip" role="dialog" aria-live="polite">
        <header>
          <h3 id="ttTitle">Title</h3>
          <button class="close" id="ttClose" aria-label="Close">×</button>
        </header>
        <div class="body" id="ttBody">Description…</div>
      </div>

      <svg id="world" viewBox="0 0 1000 600" preserveAspectRatio="xMidYMid meet" aria-label="Interactive world map">
        <defs>
          <filter id="fuzzyEdge" x="-4%" y="-4%" width="108%" height="108%">
            <feGaussianBlur in="SourceAlpha" stdDeviation="2.5" result="blur" />
            <feComposite in="SourceGraphic" in2="blur" operator="in" />
          </filter>
        </defs>
        <image id="mapImage" href="" x="0" y="0" width="1000" height="600" preserveAspectRatio="xMidYMid meet" />
        <g id="regions"></g>
        <g id="points"></g>
        <g id="editHandles"></g>
      </svg>
    </div>

    <aside class="side reveal" id="sidePanel">
      <header>
        <h1>Campaign Info</h1>
        <span class="muted">Click the map to explore</span>
      </header>
      <div class="content">
        <h3 class="lore-title" id="loreTitle">Welcome</h3>
        <div class="lore-body" id="loreBody">Use the map to learn about regions like <b>Oscana</b>, <b>Athium</b>, <b>Eturia</b>, and the island of <b>Signika</b>. On mobile, tap points; on desktop, click to open details. <br/><br/>GM Mode lets you add points and draw regions. Data is saved to your browser and can be exported as JSON for a future database.</div>
      </div>
    </aside>
  </div>

  <div class="primer reveal" id="primerBottom">
    <h2>Primer – Details</h2>
    <div id="primerDetails">Add your campaign factions, tone, safety tools, character hooks, and session 0 notes here. Enable GM mode to edit this section.</div>
  </div>

<script>
(function(){
  const JSON_PATH = './world-data.json';
  const DEFAULT_MAP_PATH = './map/world-map.png';
  const STORAGE_KEY = 'signika.world.v29';
  const DEFAULT_REGION_COLOR = '#c99a3b';

  const defaultData = {
    mapSrc: DEFAULT_MAP_PATH,
    mapSize: {w:1000,h:600},
    primerIntro: 'This is your editable campaign introduction. Enable GM mode to edit this text.',
    primerDetails: 'Add your campaign factions, tone, safety tools, character hooks, and session 0 notes here. Enable GM mode to edit this section.',
    features: [
      { id: uid(), type:'region', name:'Oscana', color: DEFAULT_REGION_COLOR, desc:'Western continent of divided kingdoms and feudal intrigue.', shapes:[[ {x:195,y:140},{x:415,y:150},{x:430,y:250},{x:300,y:270},{x:200,y:230} ]] },
      { id: uid(), type:'region', name:'Athium', color: DEFAULT_REGION_COLOR, desc:'Imperial power in the southeast; militarised and ambitious.', shapes:[[ {x:720,y:180},{x:900,y:190},{x:870,y:430},{x:690,y:410} ]] },
      { id: uid(), type:'region', name:'Eturia', color: DEFAULT_REGION_COLOR, desc:'Magocracy to the south—politics by spellbook.', shapes:[[ {x:480,y:450},{x:580,y:520},{x:520,y:580},{x:450,y:520} ], [ {x:600,y:480},{x:640,y:500},{x:620,y:530} ]] },
      { id: uid(), type:'point', name:'Signika', desc:'A wild northern island. Greywake port at the south. Recently crawling with strange, empowered monsters.', x:560, y:160 }
    ]
  };

  let state = null;

  const svg = document.getElementById('world');
  const mapWrap = document.getElementById('mapWrap');
  const gRegions = document.getElementById('regions');
  const gPoints = document.getElementById('points');
  const editHandles = document.getElementById('editHandles');
  const loreTitle = document.getElementById('loreTitle');
  const loreBody = document.getElementById('loreBody');
  const mapImage = document.getElementById('mapImage');
  const loader = document.getElementById('loader');
  const loaderText = document.getElementById('loaderText');

  const primerIntro = document.getElementById('primerIntro');
  const primerDetails = document.getElementById('primerDetails');
  const primerIntroEdit = document.getElementById('primerIntroEdit');
  const primerDetailsEdit = document.getElementById('primerDetailsEdit');

  const gmBtn = document.getElementById('gmBtn');
  const cms = document.getElementById('cms');
  const mapFile = document.getElementById('mapFile');
  const toolSelect = document.getElementById('toolSelect');
  const toolAddPoint = document.getElementById('toolAddPoint');
  const toolAddRegion = document.getElementById('toolAddRegion');
  const toolAddShape = document.getElementById('toolAddShape');
  const exportBtn = document.getElementById('toolExport');
  const importFile = document.getElementById('importFile');
  const featurePicker = document.getElementById('featurePicker');
  const featName = document.getElementById('featName');
  const featDesc = document.getElementById('featDesc');
  const featColor = document.getElementById('featColor');
  const rowColor = document.getElementById('rowColor');
  const shapeManager = document.getElementById('shapeManager');
  const shapeList = document.getElementById('shapeList');
  const featureList = document.getElementById('featureList');

  const gmModal = document.getElementById('gmModal');
  const gmBackdrop = document.getElementById('gmBackdrop');
  const gmPass = document.getElementById('gmPass');
  const gmSubmit = document.getElementById('gmSubmit');
  const gmCancel = document.getElementById('gmCancel');
  const gmError = document.getElementById('gmError');

  const tooltip = document.getElementById('tooltip');
  const ttTitle = document.getElementById('ttTitle');
  const ttBody = document.getElementById('ttBody');
  const ttClose = document.getElementById('ttClose');

  let mapW = 1000, mapH = 600;
  let view = {x:0,y:0,w:1000,h:600};
  function applyView(){ svg.setAttribute('viewBox', `${view.x} ${view.y} ${view.w} ${view.h}`); }
  function applyMapSrc(){ if(state.mapSrc){ mapImage.setAttribute('href', state.mapSrc); } mapImage.setAttribute('width', mapW); mapImage.setAttribute('height', mapH); }

  init();
  async function init(){
    showLoader('Loading world…');
    try{
      const res = await fetch(JSON_PATH, {cache:'no-store'});
      if(!res.ok) throw new Error('JSON not found');
      const data = await res.json();
      state = migrate({
        mapSrc: data.mapImage || data.mapSrc || DEFAULT_MAP_PATH,
        mapSize: data.mapSize || {w:1000,h:600},
        features: data.features || [],
        primerIntro: data.primerIntro ?? defaultData.primerIntro,
        primerDetails: data.primerDetails ?? defaultData.primerDetails
      });
    }catch(err){
      console.warn('Falling back to defaults/localStorage:', err);
      state = migrate(load()) || defaultData;
    }
    mapW = state.mapSize?.w || 1000; mapH = state.mapSize?.h || 600;
    view = {x: mapW*0.15, y: mapH*0.12, w: mapW*0.7, h: mapH*0.7};
    primerIntro.textContent = state.primerIntro || '';
    primerDetails.textContent = state.primerDetails || '';
    applyMapSrc(); applyView();
    render();
    hideLoader();
    setupReveal();
  }

  function showLoader(msg){ loaderText.textContent = msg||'Loading…'; loader.style.display='flex'; }
  function hideLoader(){ loader.style.display='none'; }

  function render(){
    gRegions.innerHTML=''; gPoints.innerHTML=''; editHandles.innerHTML='';

    state.features.filter(f=>f.type==='region').forEach(f=>{
      const g = elNS('g'); g.classList.add('feature','region'); g.setAttribute('data-id', f.id);
      const color = f.color || DEFAULT_REGION_COLOR;
      f.shapes.forEach((shape)=>{
        const path = elNS('path');
        path.setAttribute('d', roundedPolygonPath(shape, 10));
        path.setAttribute('fill', color);
        path.setAttribute('fill-opacity', '0.31');
        path.setAttribute('stroke','none');
        path.style.filter = 'url(#fuzzyEdge)';
        path.addEventListener('pointerdown', (e)=>{
          if(!gmOpen || currentTool==='select'){ startPanOnBackground(e); }
          if(gmOpen && (e.ctrlKey||e.metaKey)) { startDragRegionMove(e, f); isDraggingFeature=true; }
        });
        g.appendChild(path);
      });
      attachRegionGroupHandlers(g, f);
      gRegions.appendChild(g);

      if(selectedId===f.id && gmOpen){
        f.shapes.forEach((shape, sIdx)=>{
          shape.forEach((p,idx)=>{
            const h = elNS('circle'); h.setAttribute('cx', p.x); h.setAttribute('cy', p.y); h.setAttribute('r', 6); h.classList.add('edit-handle');
            h.addEventListener('pointerdown', (e)=> startDragVertex(e, f, sIdx, idx));
            h.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); if(e.altKey){ deleteVertex(f, sIdx, idx); render(); } });
            editHandles.appendChild(h);
          });
          for(let i=0;i<shape.length;i++){
            const a=shape[i], b=shape[(i+1)%shape.length];
            const mx=(a.x+b.x)/2, my=(a.y+b.y)/2; const m = elNS('circle');
            m.setAttribute('cx', mx); m.setAttribute('cy', my); m.setAttribute('r', 6); m.classList.add('edge-handle');
            m.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); insertVertexAtEdge(f, sIdx, i, {x:mx, y:my}); render(); });
            editHandles.appendChild(m);
          }
        });
      }
    });

    state.features.filter(f=>f.type==='point').forEach(f=>{
      const g = elNS('g'); g.classList.add('feature','point'); g.setAttribute('data-id', f.id);
      const c = elNS('circle'); c.setAttribute('cx', f.x); c.setAttribute('cy', f.y); c.setAttribute('r', 18);
      const label = elNS('text'); label.setAttribute('x', f.x + 30); label.setAttribute('y', f.y - 30); label.classList.add('label'); label.textContent = f.name;
      g.appendChild(c); g.appendChild(label); attachPointHandlers(g, f); gPoints.appendChild(g);
    });

    refreshPicker(); refreshList(); updateStates(); refreshShapeListUI(); save();
  }

  function attachRegionGroupHandlers(g, f){
    const isCoarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
    g.addEventListener('pointerenter', ()=>{ if(isCoarse) return; hoveredId=f.id; updateStates(); });
    g.addEventListener('pointerleave', ()=>{ if(isCoarse) return; hoveredId=null; updateStates(); });
    g.addEventListener('click', (e)=>{
      e.stopPropagation();
      selectedId=f.id; updateStates(); setLore(f);
      showTooltipFor(f, e);
      if(gmOpen){ selectFeature(f.id); render(); }
    });
  }
  function attachPointHandlers(node,f){
    node.addEventListener('click', (e)=>{
      e.stopPropagation(); selectedId=f.id; updateStates(); openLore(f); showTooltipFor(f, e);
      if(gmOpen) { selectFeature(f.id); render(); }
    });
    node.addEventListener('pointerdown', (e)=>{
      if(!gmOpen) { startPanOnBackground(e); return; }
      if(currentTool==='select' || currentTool==='add-point'){ selectFeature(f.id); startDragPoint(e, f); isDraggingFeature=true; }
    });
  }

  mapWrap.addEventListener('click', (e)=>{
    if(!tooltip.classList.contains('open')) return;
    if(e.target.closest('.tooltip')) return;
    if(e.target.closest('.feature')) return;
    tooltip.classList.remove('open');
  });

  function updateStates(){
    gRegions.querySelectorAll('.feature.region').forEach(g=>{
      const id=g.getAttribute('data-id');
      g.classList.toggle('hover', id===hoveredId);
      g.classList.toggle('selected', id===selectedId);
    });
  }

  function setLore(f){ loreTitle.textContent = f.name; loreBody.textContent = f.desc || ''; }
  function openLore(f){ setLore(f); }

  function showTooltipFor(f, evt){
    if(!f) return; ttTitle.textContent = f.name || '—'; ttBody.textContent = f.desc || '';
    tooltip.classList.add('open'); positionTooltip(evt);
  }
  function positionTooltip(evt){
    const wrapRect = mapWrap.getBoundingClientRect();
    const ttRect = tooltip.getBoundingClientRect();
    let x = (evt?.clientX ?? wrapRect.left) - wrapRect.left + 12;
    let y = (evt?.clientY ?? wrapRect.top) - wrapRect.top + 12;
    const maxX = wrapRect.width - ttRect.width - 8;
    const maxY = wrapRect.height - ttRect.height - 8;
    x = Math.max(8, Math.min(maxX, x));
    y = Math.max(8, Math.min(maxY, y));
    tooltip.style.left = x + 'px';
    tooltip.style.top = y + 'px';
  }
  ttClose.addEventListener('click', (e)=>{ e.stopPropagation(); tooltip.classList.remove('open'); });

  let gmOpen = false; let currentTool = 'select'; let buildingRegion = null; let buildingShapeTargetRegionId = null; let isPanning = false; let panStart = null; let selectedId = null; let hoveredId=null; let isDraggingFeature=false;
  function setTool(t){ currentTool = t; [toolSelect, toolAddPoint, toolAddRegion, toolAddShape].forEach(btn=> btn && btn.classList.remove('primary')); if(t==='select') toolSelect?.classList.add('primary'); if(t==='add-point') toolAddPoint?.classList.add('primary'); if(t==='add-region') toolAddRegion?.classList.add('primary'); if(t==='add-shape') toolAddShape?.classList.add('primary'); }
  setTool('select');

  gmBtn?.addEventListener('click', ()=>{ if(!gmOpen){ gmModal?.classList.add('open'); gmError.style.display='none'; gmPass.value=''; setTimeout(()=> gmPass.focus(), 0); } else { gmOpen=false; cms?.classList.remove('open'); gmBtn.textContent='GM'; cancelBuild(); render(); } });
  function unlockGM(){ if(gmPass.value==='1234'){ gmOpen=true; cms?.classList.add('open'); gmBtn.textContent='GM ✓'; gmModal?.classList.remove('open'); primerIntroEdit.value = state.primerIntro || ''; primerDetailsEdit.value = state.primerDetails || ''; } else { gmError.style.display='block'; } }
  gmSubmit?.addEventListener('click', unlockGM); gmCancel?.addEventListener('click', ()=> gmModal?.classList.remove('open')); gmBackdrop?.addEventListener('click', ()=> gmModal?.classList.remove('open')); gmPass?.addEventListener('keydown', (e)=>{ if(e.key==='Enter') unlockGM(); if(e.key==='Escape') gmModal?.classList.remove('open'); });

  toolSelect.addEventListener('click', ()=> setTool('select'));
  toolAddPoint.addEventListener('click', ()=> setTool('add-point'));
  toolAddRegion.addEventListener('click', ()=> setTool('add-region'));
  toolAddShape.addEventListener('click', ()=>{
    const f = featureById(selectedId);
    if(!f || f.type!=='region'){ alert('Select a region first'); return; }
    buildingShapeTargetRegionId = f.id;
    buildingRegion = { id:f.id, type:'region', addingShape:true, shape:[] };
    setTool('add-shape');
  });

  svg.addEventListener('click', (e)=>{
    if(!gmOpen) return; const pt = svgPoint(e);
    if(currentTool==='add-point'){
      const f = { id:uid(), type:'point', name:'New Point', desc:'', x:pt.x, y:pt.y };
      state.features.push(f); render(); selectFeature(f.id); openLore(f); return;
    }
    if(currentTool==='add-region'){
      if(!buildingRegion){
        const r = { id:uid(), type:'region', name:'New Region', color: DEFAULT_REGION_COLOR, desc:'', shapes:[[ {x:pt.x,y:pt.y} ]] };
        state.features.push(r); buildingRegion = r; selectedId=r.id; render(); selectFeature(r.id);
      } else {
        const shape = buildingRegion.shapes[ buildingRegion.shapes.length-1 ];
        shape.push({x:pt.x,y:pt.y}); render(); selectFeature(buildingRegion.id);
      }
      return;
    }
    if(currentTool==='add-shape' && buildingRegion && buildingShapeTargetRegionId){
      const r = featureById(buildingShapeTargetRegionId); if(!r) return;
      if(!buildingRegion.shape.length){
        const s = 24; const half = s/2;
        const square = [
          {x:pt.x-half, y:pt.y-half},
          {x:pt.x+half, y:pt.y-half},
          {x:pt.x+half, y:pt.y+half},
          {x:pt.x-half, y:pt.y+half}
        ];
        r.shapes.push(square);
        buildingRegion = null; buildingShapeTargetRegionId = null; setTool('select');
        render(); selectFeature(r.id);
      }
      return;
    }
  });

  svg.addEventListener('dblclick', ()=>{
    if(!gmOpen) return;
    if(currentTool==='add-region'){
      const r = buildingRegion; if(!r) return; const shape = r.shapes[r.shapes.length-1];
      if(shape.length<3){ alert('Need at least 3 points for a shape.'); return; }
      buildingRegion = null; setTool('select'); render();
    }
  });
  function cancelBuild(){ buildingRegion=null; buildingShapeTargetRegionId=null; }

  function startDragPoint(e, f){
    e.preventDefault();
    const start = svgPoint(e);
    const offset = { x: f.x - start.x, y: f.y - start.y };
    const move=(ev)=>{ const p=svgPoint(ev); f.x=clamp(p.x + offset.x,0,mapW); f.y=clamp(p.y + offset.y,0,mapH); render(); selectFeature(f.id,false); };
    const up=()=>{ off(move,up); isDraggingFeature=false; save(); };
    on(move,up);
  }
  function startDragRegionMove(e, f){
    const p=svgPoint(e);
    const offset={x:p.x,y:p.y};
    const move=(ev)=>{ const q=svgPoint(ev); const dx=q.x-offset.x, dy=q.y-offset.y; f.shapes=f.shapes.map(shape=> shape.map(pt=>({x:clamp(pt.x+dx,0,mapW),y:clamp(pt.y+dy,0,mapH)})) ); offset.x=q.x; offset.y=q.y; render(); selectFeature(f.id,false); };
    const up=()=>{ off(move,up); isDraggingFeature=false; save(); };
    on(move,up);
  }
  function startDragVertex(e, f, sIdx, idx){
    e.preventDefault(); e.stopPropagation();
    const start = svgPoint(e);
    const startPt = { x: f.shapes[sIdx][idx].x, y: f.shapes[sIdx][idx].y };
    const offset = { x: startPt.x - start.x, y: startPt.y - start.y };
    const move=(ev)=>{ const p=svgPoint(ev); f.shapes[sIdx][idx]={x:clamp(p.x + offset.x,0,mapW),y:clamp(p.y + offset.y,0,mapH)}; render(); selectFeature(f.id,false); };
    const up=()=>{ off(move,up); isDraggingFeature=false; save(); };
    on(move,up);
  }
  function on(move,up){ window.addEventListener('pointermove',move); window.addEventListener('pointerup',up, { once:true }); }
  function off(move,up){ window.removeEventListener('pointermove',move); }
  function insertVertexAtEdge(f,sIdx,i,p){ f.shapes[sIdx].splice(i+1,0,{x:p.x,y:p.y}); }
  function deleteVertex(f,sIdx,idx){ if(f.shapes[sIdx].length<=3){ deleteShape(f, sIdx); return; } f.shapes[sIdx].splice(idx,1); }
  function deleteShape(f, sIdx){ f.shapes.splice(sIdx,1); }

  const zoomIn = document.getElementById('zoomIn');
  const zoomOut = document.getElementById('zoomOut');
  const zoomReset = document.getElementById('zoomReset');
  function zoom(factor, center){ const cx=center?.x ?? (view.x+view.w/2); const cy=center?.y ?? (view.y+view.h/2); const nw=clamp(view.w*factor, 200, mapW); const nh=clamp(view.h*factor, 120, mapH); view.x=clamp(cx-nw/2,0,Math.max(0,mapW-nw)); view.y=clamp(cy-nh/2,0,Math.max(0,mapH-nh)); view.w=nw; view.h=nh; applyView(); }
  zoomIn?.addEventListener('click', ()=> zoom(0.8));
  zoomOut?.addEventListener('click', ()=> zoom(1.25));
  zoomReset?.addEventListener('click', ()=>{ view={x:0,y:0,w:mapW,h:mapH}; applyView(); });

  svg.addEventListener('wheel', (e)=>{ e.preventDefault(); const pt=svgPoint(e); const factor = e.deltaY>0 ? 1.15 : 0.85; zoom(factor, pt); }, {passive:false});

  function startPanOnBackground(e){ if(e.button!==0 && e.pointerType!=='touch') return; e.preventDefault(); isPanning=true; const rect=svg.getBoundingClientRect(); panStart={ sx:e.clientX, sy:e.clientY, vx:view.x, vy:view.y, rw:view.w/rect.width, rh:view.h/rect.height }; if(e.target && e.target.setPointerCapture){ try{ e.target.setPointerCapture(e.pointerId);}catch(_){ } } }
  svg.addEventListener('pointerdown', (e)=>{ if(isDraggingFeature) return; if(e.button!==0 && e.pointerType!=='touch') return; if(e.target === svg || e.target === mapImage || e.target.closest('g.feature')){ startPanOnBackground(e); } });
  svg.addEventListener('pointermove', (e)=>{ if(!isPanning) return; const dx=(e.clientX-panStart.sx)*panStart.rw; const dy=(e.clientY-panStart.sy)*panStart.rh; view.x=clamp(panStart.vx-dx,0,Math.max(0,mapW-view.w)); view.y=clamp(panStart.vy-dy,0,Math.max(0,mapH-view.h)); applyView(); });
  svg.addEventListener('pointerup', ()=>{ isPanning=false; panStart=null; });

  let touches = new Map(); let pinchBase=null;
  svg.addEventListener('pointerdown', (e)=>{ if(e.pointerType==='touch'){ touches.set(e.pointerId, e); try{ svg.setPointerCapture(e.pointerId);}catch(_){} }});
  svg.addEventListener('pointerup', (e)=>{ if(e.pointerType==='touch'){ touches.delete(e.pointerId); if(touches.size<2) pinchBase=null; }});
  svg.addEventListener('pointercancel', (e)=>{ if(e.pointerType==='touch'){ touches.delete(e.pointerId); if(touches.size<2) pinchBase=null; }});
  svg.addEventListener('pointermove', (e)=>{
    if(e.pointerType!=='touch') return; if(touches.has(e.pointerId)) touches.set(e.pointerId,e);
    if(touches.size===2){
      const [a,b]=[...touches.values()];
      const dNow = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
      const mid = { clientX:(a.clientX+b.clientX)/2, clientY:(a.clientY+b.clientY)/2 };
      const pt = svgPoint(mid);
      if(!pinchBase){ pinchBase={d:dNow}; return; }
      const scale = dNow / pinchBase.d;
      const factor = 1/scale;
      pinchBase.d = dNow;
      zoom(factor, pt);
    }
  });

  function refreshPicker(){ const id=selectedId; featurePicker.innerHTML = state.features.map(f=>`<option value="${f.id}">${escapeHTML(f.name)} (${f.type})</option>`).join(''); if(id){ const idx=state.features.findIndex(f=>f.id===id); featurePicker.selectedIndex = idx>=0 ? idx : 0; } onPickerChange(); }
  function refreshList(){ featureList.innerHTML=''; state.features.forEach(f=>{ const div=document.createElement('div'); div.className='item'; const tint = f.type==='region' ? `<span class="chip" style="background:${f.color||DEFAULT_REGION_COLOR};color:#0b0e15;border:none">&nbsp;&nbsp;</span>` : ''; div.innerHTML=`<div class="meta">${tint}<span class="chip">${f.type}</span><strong>${escapeHTML(f.name)}</strong></div><div class="toolbar" style="display:flex;gap:8px"><button class="btn" data-act="edit" type="button">Edit</button></div>`; div.querySelector('[data-act="edit"]').addEventListener('click', ()=>{ selectFeature(f.id); }); featureList.appendChild(div); }); }
  function onPickerChange(){ const id=featurePicker.value; if(!id) return; const f=state.features.find(x=>x.id===id); if(!f) return; selectedId=id; featName.value=f.name||''; featDesc.value=f.desc||''; if(f.type==='region'){ rowColor.style.display='grid'; featColor.value=(f.color||DEFAULT_REGION_COLOR); shapeManager.style.display='grid'; } else { rowColor.style.display='none'; shapeManager.style.display='none'; } updateStates(); refreshShapeListUI(); }
  featurePicker.addEventListener('change', onPickerChange);
  function selectFeature(id, updatePicker=true){ selectedId=id; if(updatePicker) refreshPicker(); onPickerChange(); }

  featName.addEventListener('input', ()=>{ const f=featureById(selectedId); if(!f) return; f.name=featName.value; refreshPicker(); refreshList(); save(); });
  featDesc.addEventListener('input', ()=>{ const f=featureById(selectedId); if(!f) return; f.desc=featDesc.value; save(); });

  primerIntroEdit.addEventListener('input', ()=>{ state.primerIntro = primerIntroEdit.value; primerIntro.textContent = state.primerIntro; save(); });
  primerDetailsEdit.addEventListener('input', ()=>{ state.primerDetails = primerDetailsEdit.value; primerDetails.textContent = state.primerDetails; save(); });

  let colorRAF = 0;
  featColor.addEventListener('input', ()=>{
    const f = featureById(selectedId);
    if(!f || f.type!=='region') return;
    f.color = featColor.value || DEFAULT_REGION_COLOR;
    if(colorRAF) cancelAnimationFrame(colorRAF);
    colorRAF = requestAnimationFrame(()=>{ updateRegionColorDOM(f); save(); });
  });
  function updateRegionColorDOM(f){
    const g = gRegions.querySelector(`.feature.region[data-id="${CSS.escape(f.id)}"]`);
    if(!g) { render(); return; }
    g.querySelectorAll('path').forEach(p=> p.setAttribute('fill', f.color || DEFAULT_REGION_COLOR));
  }

  mapFile.addEventListener('change', (e)=>{ const file=e.target.files?.[0]; if(!file) return; const reader=new FileReader(); reader.onload=()=>{ try{ const dataUrl=reader.result; const img=new Image(); img.onload=()=>{ mapW=img.naturalWidth; mapH=img.naturalHeight; state.mapSize={w:mapW,h:mapH}; view={x:0,y:0,w:mapW,h:mapH}; mapImage.setAttribute('width',mapW); mapImage.setAttribute('height',mapH); svg.setAttribute('viewBox',`0 0 ${mapW} ${mapH}`); state.mapSrc=dataUrl; applyMapSrc(); applyView(); render(); save(); }; img.src=dataUrl; }catch(err){ alert('Could not load image'); } }; reader.readAsDataURL(file); });

  exportBtn.addEventListener('click', ()=>{
    try{
      const out = { mapImage: state.mapSrc, mapSize: state.mapSize, primerIntro: state.primerIntro || '', primerDetails: state.primerDetails || '', features: state.features };
      const data = JSON.stringify(out, null, 2);
      const blob = new Blob([data], {type:'application/json'});
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url; a.download = 'world-data.json';
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
    }catch(err){ alert('Export failed: ' + (err?.message||err)); }
  });
  importFile.addEventListener('change', (e)=>{ const file=e.target.files?.[0]; if(!file) return; const reader=new FileReader(); reader.onload=()=>{ try{ const obj=JSON.parse(reader.result);
      if(obj.features) state.features=obj.features.map(f=> migrateFeature(f));
      if(obj.mapImage||obj.mapSrc) state.mapSrc=obj.mapImage||obj.mapSrc; if(obj.mapSize){ state.mapSize=obj.mapSize; mapW=state.mapSize.w; mapH=state.mapSize.h; mapImage.setAttribute('width',mapW); mapImage.setAttribute('height',mapH); svg.setAttribute('viewBox',`0 0 ${mapW} ${mapH}`); view={x:0,y:0,w:mapW,h:mapH}; }
      if('primerIntro' in obj){ state.primerIntro = obj.primerIntro; primerIntro.textContent = state.primerIntro; }
      if('primerDetails' in obj){ state.primerDetails = obj.primerDetails; primerDetails.textContent = state.primerDetails; }
      applyMapSrc(); applyView(); render(); save(); }catch(err){ alert('Invalid JSON'); } }; reader.readAsText(file); });

  function featureById(id){ return state.features.find(x=>x.id===id); }
  function uid(){ return Math.random().toString(36).slice(2) + Date.now().toString(36); }
  function save(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch(e){} }
  function load(){ try{ const s = localStorage.getItem(STORAGE_KEY); return s? JSON.parse(s): null; }catch(e){ return null; } }
  function migrate(s){ if(!s) return null; if(!s.mapSize){ s.mapSize={w:1000,h:600}; }
    if(Array.isArray(s.features)) s.features = s.features.map(f=> migrateFeature(f));
    if(typeof s.primerIntro !== 'string') s.primerIntro = defaultData.primerIntro;
    if(typeof s.primerDetails !== 'string') s.primerDetails = defaultData.primerDetails;
    return s; }
  function migrateFeature(f){ if(f.type==='region'){ if(!f.shapes && f.points){ f.shapes=[f.points]; delete f.points; } f.color = f.color || DEFAULT_REGION_COLOR; return f; } else { return f; } }
  function svgPoint(evt){
    const rect=svg.getBoundingClientRect();
    const clientX = evt?.clientX ?? rect.left;
    const clientY = evt?.clientY ?? rect.top;
    const x = view.x + (clientX - rect.left) * (view.w / rect.width);
    const y = view.y + (clientY - rect.top) * (view.h / rect.height);
    return {x,y}; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function elNS(name){ return document.createElementNS('http://www.w3.org/2000/svg', name); }
  function escapeHTML(s){ return (s||'').replace(/[&<>\"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

  function roundedPolygonPath(points, radius){
    const n=points.length; if(n<3) return '';
    const r = Math.max(0, radius|0);
    function lerp(a,b,t){ return {x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t}; }
    function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
    let d='';
    for(let i=0;i<n;i++){
      const p0=points[(i-1+n)%n], p1=points[i], p2=points[(i+1)%n];
      const rr = Math.min(r, dist(p1,p0)/2, dist(p1,p2)/2);
      const pA = lerp(p1, p0, rr/dist(p1,p0));
      const pB = lerp(p1, p2, rr/dist(p1,p2));
      if(i===0){ d += `M ${pA.x} ${pA.y} `; }
      d += `L ${pA.x} ${pA.y} Q ${p1.x} ${p1.y} ${pB.x} ${pB.y} `;
    }
    d += 'Z';
    return d;
  }

  function refreshShapeListUI(){
    const f = featureById(selectedId);
    shapeList.innerHTML='';
    if(!f || f.type!=='region'){ shapeManager.style.display='none'; return; }
    shapeManager.style.display='grid';
    f.shapes.forEach((shape, idx)=>{
      const div=document.createElement('div'); div.className='item';
      div.innerHTML = `<div class="meta"><span class="chip">Shape ${idx+1}</span><span class="muted">${shape.length} pts</span></div>`+
                      `<div class="toolbar" style="display:flex;gap:8px"><button class="btn danger" data-del>Delete Shape</button></div>`;
      div.querySelector('[data-del]').addEventListener('click', ()=>{
        if(!confirm('Delete this shape from the region?')) return;
        deleteShape(f, idx); render(); selectFeature(f.id);
      });
      shapeList.appendChild(div);
    });
  }

  (function runTests(){
    try{
      console.assert(svg && gRegions && gPoints && mapImage, 'TEST: core SVG elements exist');
      const f={id:'t', type:'region', name:'T', color:'#fff', shapes:[[ {x:0,y:0},{x:20,y:0},{x:20,y:20},{x:0,y:20} ], [ {x:40,y:40},{x:60,y:40},{x:60,y:60},{x:40,y:60} ]]};
      deleteShape(f,1); console.assert(f.shapes.length===1, 'TEST: deleteShape removes a shape');
    }catch(e){ console.warn('Tests failed:', e); }
  })();

  function setupReveal(){
    const els = document.querySelectorAll('.reveal');
    const obs = new IntersectionObserver(entries=>{
      entries.forEach(entry=>{ if(entry.isIntersecting){ entry.target.classList.add('visible'); obs.unobserve(entry.target); }});
    },{threshold:.1});
    els.forEach(el=>obs.observe(el));
  }

})();
</script>
</body>
</html>
