<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The World of Draelon – Campaign Primer (v44)</title>
  <style>
    :root{
      --bg:#efe7d2; --paper:#fbf3dd; --paper-2:#f6edd1; --ink:#2c2416; --ink-soft:#5c523f;
      --accent:#8b5e34; --rule:#d8caa6; --edge:#cbb98f; --shadow:0 18px 40px rgba(0,0,0,.25); --radius:16px;
      --wrap:clamp(895px, 90vw, 1400px);
    }
    html,body{height:100%}
    body{
      margin:0; color:var(--ink);
      background: radial-gradient(1200px 800px at 60% 0%, #f9f1d9 0%, #efe7d2 60%, #e7dbbd 100%);
      font-family: Georgia, "Iowan Old Style", "Palatino Linotype", serif; line-height:1.4;
      -webkit-tap-highlight-color: transparent;
    }
    *{ user-select: none; -webkit-user-select: none; -ms-user-select: none; }
    input, textarea, select, .gm-modal, .cms, .island-lore, .primer, .side .content{
      user-select: text; -webkit-user-select: text;
    }
    body:before{
      content:""; position:fixed; inset:0; pointer-events:none;
      background:
        radial-gradient(800px 400px at 40% -10%, rgba(139,94,52,.07), transparent 60%),
        radial-gradient(600px 600px at 90% 0%, rgba(58,90,64,.08), transparent 70%),
        repeating-linear-gradient(0deg, rgba(0,0,0,.03), rgba(0,0,0,.03) 1px, transparent 2px, transparent 4px);
      mix-blend-mode:multiply; opacity:.6;
    }
    .primer,.panel{
      background: linear-gradient(180deg, var(--paper), var(--paper-2));
      border: 1px solid var(--edge);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position:relative;
    }
    .primer::after,.panel::after{
      content:""; position:absolute; inset:0; pointer-events:none;
      border-radius: var(--radius);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.04), inset 0 30px 60px rgba(0,0,0,.06);
    }
    .primer{margin:16px; padding:18px 18px 14px}
    .primer h2{ margin:0 0 10px 0; font-size:26px; letter-spacing:.5px; text-transform:uppercase; font-weight:700; border-bottom:2px solid var(--rule); padding-bottom:6px; }
    .app{ display:grid; grid-template-columns: 1fr; gap:0; }
    .map-row{display:flex; justify-content:center}
    .map-wrap{
      position:relative;
      width:100%; max-width:var(--wrap);
      min-height:60vh; max-height:82vh;
      margin:16px; overflow:hidden;
    }
    @media (min-width: 1400px){ .map-wrap{ min-height:72vh; } }
    .map-wrap svg{
      width:100%; height:100%; display:block;
      background:#efe6c8;
      touch-action:none; cursor:grab;
    }
    .side-row{display:flex; justify-content:center}
    .side{
      width:100%; max-width:var(--wrap);
      display:flex;flex-direction:column;
      margin:0 16px 16px 16px; overflow:hidden;
    }
    .side header{padding:14px 16px;display:flex;align-items:center;justify-content:space-between;border-bottom:2px solid var(--rule);background:linear-gradient(180deg,var(--paper),var(--paper-2));border-top-left-radius:var(--radius);border-top-right-radius:var(--radius)}
    .side header h1{font-size:18px;margin:0;letter-spacing:.6px;text-transform:uppercase}
    .side .content{padding:16px;overflow:visible}
    .lore-title{font-weight:700;margin:0 0 8px;font-size:20px;letter-spacing:.2px}
    .lore-body{line-height:1.6;white-space:pre-wrap}
    .lore-media{margin:0 0 12px 0; display:none}
    .lore-media img{width:100%; height:auto; display:block; border-radius:10px; border:1px solid var(--edge); box-shadow: var(--shadow)}

    .muted{color:var(--ink-soft);font-size:12px}
    .loader{position:absolute;left:10px;top:10px;display:flex;align-items:center;gap:8px;background:rgba(255,255,255,.75);border:1px solid var(--edge);border-radius:10px;padding:6px 10px;z-index:20;backdrop-filter:blur(2px)}
    .spinner{width:14px;height:14px;border-radius:50%;border:2px solid rgba(0,0,0,.2); border-top-color:var(--accent); animation:spin .8s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .gm-btn{position:absolute;top:12px;right:12px;z-index:10;background:linear-gradient(180deg, #f7edcf, #efe2b6);color:var(--ink);border:1px solid var(--edge);border-radius:999px;padding:8px 12px;font-weight:700;cursor:pointer;box-shadow: var(--shadow)}
    .feature{cursor:pointer}
    .feature.point circle{stroke:var(--paper);stroke-width:3;fill:var(--accent)}
    .feature.point .label{font-size:36px;fill:var(--ink);pointer-events:none;paint-order:stroke;stroke:#faedcf;stroke-width:6px;stroke-linejoin:round}
    .feature.region path{stroke-width:0;transition:fill-opacity .12s linear; pointer-events:auto}
    .feature.region.hover path{fill-opacity:.35}
    .feature.region.selected path{fill-opacity:.42}

    /* Desktop tooltip (unchanged) */
    .tooltip{position:absolute;min-width:260px;max-width:420px;background:var(--paper);border:1px solid var(--edge);border-radius:12px;box-shadow: var(--shadow);z-index:1000;display:none;pointer-events:auto;overflow:hidden}
    .tooltip.open{display:block}
    .tooltip header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid var(--rule); background:linear-gradient(180deg,var(--paper),var(--paper-2)); position:relative; z-index:2}
    .tooltip header h3{margin:0;font-size:16px}
    .tooltip .close{background:transparent;border:0;color:var(--ink);cursor:pointer;font-size:18px}
    .tooltip .media{width:100%;overflow:hidden;background:#e6d9b6;border-bottom:1px solid var(--rule)}
    .tooltip .media img{width:100%;height:auto;display:block}
    .tooltip .body{padding:10px 12px;line-height:1.5; max-height:none; overflow:visible}
    .tooltip .body p{margin:0}

    /* On mobile, hide floating tooltip and keep Campaign Info usage */
    @media (max-width: 760px){
      .tooltip{ display:none !important; }
      .map-wrap{ height: min(60vh, calc(100vw * 0.72)); min-height:auto; max-height:none; }
      .map-wrap svg{ height:100%; }
      .island-grid{ grid-template-columns:1fr }
      .island-card{ max-width:min(90vw, 1024px) }
    }

    .section{margin:8px 16px 16px 16px}
    .island-grid{ display:grid; grid-template-columns:auto 1fr; gap:16px; align-items:start; max-width:1280px; margin:0 16px }
    .island-card{ margin:0; padding:12px; background:linear-gradient(180deg, var(--paper), var(--paper-2));
      border:1px solid var(--edge); border-radius: var(--radius); box-shadow: var(--shadow);
      display:inline-block; max-width:min(50vw, 1024px); }
    .island-card img{display:block; width:100%; height:auto}
    .island-lore{padding:16px}
    .island-lore h3{margin:0 0 8px 0;font-size:18px;text-transform:uppercase;letter-spacing:.4px}
    .island-lore .body{white-space:pre-wrap; line-height:1.6}
  </style>
</head>
<body>
  <div class="primer" id="primerTop">
    <h2>The World of Draelon</h2>
    <div id="primerIntro">This is your editable campaign introduction. Enable GM mode to edit this text. Players can scroll the map, tap regions, and read tooltips.</div>
  </div>
  <div class="app">
    <div class="map-row">
      <div class="map-wrap panel" id="mapWrap">
        <div class="loader" id="loader" aria-live="polite"><div class="spinner"></div><span id="loaderText">Loading world…</span></div>
        <button class="gm-btn" id="gmBtn" title="GM Mode" type="button">GM</button>
        <div class="tooltip" id="tooltip" role="dialog" aria-live="polite">
          <div class="media" id="ttMedia" style="display:none"><img id="ttImg" alt=""></div>
          <header>
            <h3 id="ttTitle">Title</h3>
            <button class="close" id="ttClose" aria-label="Close">×</button>
          </header>
          <div class="body" id="ttBody"><p>Description…</p></div>
        </div>
        <svg id="world" viewBox="0 0 1000 600" preserveAspectRatio="xMidYMid meet" aria-label="Interactive world map">
          <defs>
            <filter id="fuzzyEdge" x="-4%" y="-4%" width="108%" height="108%">
              <feGaussianBlur in="SourceAlpha" stdDeviation="2.5" result="blur" />
              <feComposite in="SourceGraphic" in2="blur" operator="in" />
            </filter>
          </defs>
          <image id="mapImage" href="" x="0" y="0" width="1000" height="600" preserveAspectRatio="none" />
          <g id="regions"></g>
          <g id="points"></g>
        </svg>
      </div>
    </div>
    <div class="side-row">
      <aside class="side panel" id="sidePanel">
        <header><h1>Campaign Info</h1><span class="muted">Click the map to explore</span></header>
        <div class="content">
          <div class="lore-media" id="loreMedia"><img id="loreImg" alt=""></div>
          <h3 class="lore-title" id="loreTitle">Welcome</h3>
          <div class="lore-body" id="loreBody">Use the map to learn about regions like <b>Oscana</b>, <b>Athium</b>, <b>Eturia</b>, and the island of <b>Signika</b>.</div>
        </div>
      </aside>
    </div>
  </div>
  <section class="section">
    <div class="island-grid">
      <figure class="island-card"><img id="islandImg" src="" alt="Signika island map"/></figure>
      <div class="island-lore panel"><h3>Island Lore</h3><div id="islandLore" class="body">Add your Signika lore here — history, factions, features, and travel notes.</div></div>
    </div>
  </section>
  <div class="primer panel" id="primerBottom">
    <h2>Primer – Details</h2>
    <div id="primerDetails">Add your campaign factions, tone, safety tools, character hooks, and session 0 notes here. Enable GM mode to edit this section.</div>
  </div>
<script>
(function(){
  const JSON_PATH = './world-data.json';
  const DEFAULT_WORLD_MAP = '/Campaign-Primer/map/world-map.png';
  const DEFAULT_ISLAND_MAP = '/Campaign-Primer/map/campaign-map.png';
  const STORAGE_KEY = 'signika.world.v44';
  let state=null;
  const mapWrap  = document.getElementById('mapWrap');
  const svgWorld = document.getElementById('world');
  const mapImage = document.getElementById('mapImage');
  const gRegions = document.getElementById('regions');
  const gPoints  = document.getElementById('points');
  const islandImg = document.getElementById('islandImg');
  const islandLore = document.getElementById('islandLore');
  const primerIntro = document.getElementById('primerIntro');
  const primerDetails = document.getElementById('primerDetails');
  const loreTitle = document.getElementById('loreTitle');
  const loreBody  = document.getElementById('loreBody');
  const loreMedia = document.getElementById('loreMedia');
  const loreImg   = document.getElementById('loreImg');
  const loader = document.getElementById('loader');
  const tooltip = document.getElementById('tooltip');
  const ttTitle = document.getElementById('ttTitle');
  const ttBody  = document.getElementById('ttBody');
  const ttMedia = document.getElementById('ttMedia');
  const ttImg   = document.getElementById('ttImg');
  const ttClose = document.getElementById('ttClose');

  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const elNS=(n)=>document.createElementNS('http://www.w3.org/2000/svg',n);
  const escapeHTML = s => (s||'').replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));

  function roundedPolygonPath(points, r){
    if(!points || points.length<2) return '';
    const n=points.length; let d='';
    for(let i=0;i<n;i++){
      const p0=points[(i-1+n)%n], p1=points[i], p2=points[(i+1)%n];
      const v1x=p1.x-p0.x, v1y=p1.y-p0.y, v2x=p2.x-p1.x, v2y=p2.y-p1.y;
      const l1=Math.hypot(v1x,v1y), l2=Math.hypot(v2x,v2y);
      const r1=Math.min(r, l1/3), r2=Math.min(r, l2/3);
      const A={x:p1.x - v1x/l1*r1, y:p1.y - v1y/l1*r1};
      const B={x:p1.x + v2x/l2*r2, y:p1.y + v2y/l2*r2};
      if(i===0) d+=`M ${A.x} ${A.y} `; else d+=`L ${A.x} ${A.y} `;
      d+=`Q ${p1.x} ${p1.y} ${B.x} ${B.y} `;
    }
    return d+'Z';
  }

  function computeCoverCrop(imgW, imgH, svgW, svgH){
    const aspect = svgW / svgH;
    let vw = Math.min(imgW, imgH * aspect);
    let vh = vw / aspect;
    if (vh > imgH) {
      vh = imgH;
      vw = vh * aspect;
      if (vw > imgW) { vw = imgW; vh = vw / aspect; }
    }
    return {vw, vh};
  }

  function makeBoundedNavigator(svgEl, imgW, imgH){
    function initialView(){
      const rect = svgEl.getBoundingClientRect();
      const {vw, vh} = computeCoverCrop(imgW, imgH, rect.width, rect.height);
      const vx = (imgW - vw) / 2;
      const vy = (imgH - vh) / 2;
      return {vx, vy, vw, vh};
    }
    let {vx,vy,vw,vh} = initialView();
    svgEl.setAttribute('viewBox', `${vx} ${vy} ${vw} ${vh}`);

    const nav={
      viewBox:[vx,vy,vw,vh],
      minW: imgW*0.08, minH: imgH*0.08, // deep zoom
      maxW: vw, maxH: vh,               // max zoom-out == cover
      panning:false, dragCandidate:false, dragged:false, start:{x:0,y:0}, last:{x:0,y:0},
      pointers:new Map(), initialPinchDist:0, initialViewBox:null
    };
    const apply=()=> svgEl.setAttribute('viewBox', nav.viewBox.join(' '));
    const atFull=()=> (Math.abs(nav.viewBox[2]-nav.maxW)<0.5 && Math.abs(nav.viewBox[3]-nav.maxH)<0.5);

    function setTouchMode(){
      if(atFull() && nav.pointers.size <= 1){ svgEl.style.touchAction = 'pan-y'; }
      else{ svgEl.style.touchAction = 'none'; }
    }

    svgEl.addEventListener('wheel', (e)=>{
      let [vx,vy,vw,vh]=nav.viewBox;
      const full = atFull();
      if(full && e.deltaY > 0){ return; } // let page scroll when scrolling down at full
      e.preventDefault();
      const scale=(e.deltaY<0?0.9:1.1);
      const mx=e.offsetX/svgEl.clientWidth, my=e.offsetY/svgEl.clientHeight;
      let nw=clamp(vw*scale, nav.minW, nav.maxW);
      let nh=clamp(vh*scale, nav.minH, nav.maxH);
      const nx=clamp(vx+(vw-nw)*mx, 0, imgW-nw);
      const ny=clamp(vy+(vh-nh)*my, 0, imgH-nh);
      nav.viewBox=[nx,ny,nw,nh]; apply(); setTouchMode();
    }, {passive:false});

    // Cancel synthetic click after panning on touch
    svgEl.addEventListener('pointerup', (e)=>{
      if(nav.panning){ if(e.cancelable) e.preventDefault(); }
    }, {passive:false, capture:true});

    svgEl.addEventListener('pointerdown', (e)=>{
      nav.pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      nav.dragCandidate = true; nav.dragged = false;
      nav.start = {x:e.clientX, y:e.clientY};
      nav.last  = {x:e.clientX, y:e.clientY};

      if(nav.pointers.size===2){
        const pts=[...nav.pointers.values()];
        nav.initialPinchDist = Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y);
        nav.initialViewBox = nav.viewBox.slice();
      }
      svgEl.style.cursor='grabbing';
      setTouchMode();
    });

    svgEl.addEventListener('pointermove', (e)=>{
      if(!nav.pointers.has(e.pointerId)) return;
      nav.pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

      if(nav.pointers.size===2){
        // Pinch zoom
        const pts=[...nav.pointers.values()];
        const dist = Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y);
        if(nav.initialPinchDist>0){
          const scale = nav.initialPinchDist / dist;
          const [vx,vy,vw,vh] = nav.initialViewBox;
          let nw = clamp(vw * scale, nav.minW, nav.maxW);
          let nh = clamp(vh * scale, nav.minH, nav.maxH);
          const mx = ((pts[0].x + pts[1].x)/2) / svgEl.clientWidth;
          const my = ((pts[0].y + pts[1].y)/2) / svgEl.clientHeight;
          let nx = clamp(vx + (vw - nw)*mx, 0, imgW - nw);
          let ny = clamp(vy + (vh - nh)*my, 0, imgH - nh);
          nav.viewBox=[nx,ny,nw,nh]; apply(); setTouchMode();
        }
        return;
      }

      // Single-finger pan with strict clamp
      if(nav.dragCandidate){
        const dx0=e.clientX - nav.start.x, dy0=e.clientY - nav.start.y;
        if(dx0*dx0 + dy0*dy0 > 16){
          nav.panning=true; nav.dragCandidate=false; nav.dragged=true;
          try{ svgEl.setPointerCapture(e.pointerId); }catch{}
        }
      }
      if(!nav.panning) return;
      let [vx,vy,vw,vh]=nav.viewBox;
      const dx=(e.clientX-nav.last.x)*(vw/svgEl.clientWidth);
      const dy=(e.clientY-nav.last.y)*(vh/svgEl.clientHeight);
      vx=clamp(vx-dx, 0, imgW - vw);
      vy=clamp(vy-dy, 0, imgH - vh);
      nav.viewBox=[vx,vy,vw,vh]; nav.last={x:e.clientX,y:e.clientY}; apply();
    });

    function endPointer(e){
      nav.pointers.delete(e.pointerId);
      nav.panning=false; nav.dragCandidate=false; nav.dragged=false;
      nav.initialPinchDist=0; nav.initialViewBox=null;
      svgEl.style.cursor='grab';
      try{ svgEl.releasePointerCapture(e.pointerId); }catch{}
      setTouchMode();
    }
    svgEl.addEventListener('pointerup', endPointer);
    svgEl.addEventListener('pointercancel', endPointer);
    svgEl.addEventListener('lostpointercapture', ()=> setTouchMode());

    // Keep cover behavior on resize, try to preserve center
    window.addEventListener('resize', ()=>{
      const rect = svgEl.getBoundingClientRect();
      const centerX = nav.viewBox[0] + nav.viewBox[2]/2;
      const centerY = nav.viewBox[1] + nav.viewBox[3]/2;
      const {vw, vh} = computeCoverCrop(imgW, imgH, rect.width, rect.height);
      nav.maxW = vw; nav.maxH = vh;
      let nw = clamp(nav.viewBox[2], nav.minW, nav.maxW);
      let nh = clamp(nav.viewBox[3], nav.minH, nav.maxH);
      let nx = clamp(centerX - nw/2, 0, imgW - nw);
      let ny = clamp(centerY - nh/2, 0, imgH - nh);
      nav.viewBox=[nx,ny,nw,nh]; apply(); setTouchMode();
    });

    return { reset:()=>{
      const rect = svgEl.getBoundingClientRect();
      const {vw, vh} = computeCoverCrop(imgW, imgH, rect.width, rect.height);
      const vx = (imgW - vw) / 2;
      const vy = (imgH - vh) / 2;
      nav.maxW = vw; nav.maxH = vh;
      nav.viewBox=[vx,vy,vw,vh]; apply(); setTouchMode();
    } };
  }

  init().catch(console.error);

  async function init(){
    const data = await loadData();
    state = data || {};
    primerIntro.textContent = state.primerIntro || '';
    primerDetails.textContent = state.primerDetails || '';
    islandLore.textContent = state.islandLore || islandLore.textContent;

    const wSize = state.mapSize || {w:4080,h:3072};
    mapImage.setAttribute('href', state.mapSrc || DEFAULT_WORLD_MAP);
    mapImage.setAttribute('width', wSize.w); mapImage.setAttribute('height', wSize.h);
    svgWorld.setAttribute('viewBox', `0 0 ${wSize.w} ${wSize.h}`);

    islandImg.src = state.campaignMapSrc || state.campaignMap || DEFAULT_ISLAND_MAP;
    islandImg.alt = "Signika island map";

    renderFeatures();
    makeBoundedNavigator(svgWorld, wSize.w, wSize.h);

    ttClose.addEventListener('click', ()=> tooltip.classList.remove('open'));
    svgWorld.addEventListener('click', (e)=>{
      const isFeature = !!e.target.closest('.feature');
      const isMobile = window.matchMedia('(max-width: 760px)').matches;
      if(!isFeature){
        if(!isMobile && tooltip.classList.contains('open')) tooltip.classList.remove('open');
      }
    });

    loader.style.display='none';
  }

  async function loadData(){
    try{
      const res = await fetch(JSON_PATH, {cache:'no-store'});
      if(!res.ok) throw 0;
      const data = await res.json();
      return {
        mapSrc: data.mapImage || data.mapSrc || DEFAULT_WORLD_MAP,
        mapSize: data.mapSize || {w:4080,h:3072},
        campaignMapSrc: data.campaignMap || data.campaignMapSrc || DEFAULT_ISLAND_MAP,
        campaignMapSize: data.campaignMapSize || {w:1024,h:1024},
        features: data.features || [],
        primerIntro: data.primerIntro || '',
        primerDetails: data.primerDetails || '',
        islandLore: data.islandLore || ''
      };
    }catch(e){
      return { mapSrc: DEFAULT_WORLD_MAP, mapSize:{w:4080,h:3072}, campaignMapSrc: DEFAULT_ISLAND_MAP,
               campaignMapSize:{w:1024,h:1024}, features:[], primerIntro:'', primerDetails:'', islandLore:'' };
    }
  }

  function renderFeatures(){
    gRegions.innerHTML=''; gPoints.innerHTML='';
    const feats = (state.features||[]);

    // Regions
    feats.filter(f=>f.type==='region').forEach(f=>{
      const g=elNS('g'); g.classList.add('feature','region'); g.dataset.id=f.id||'';
      const color=f.color||'#8ad9ff';
      (f.shapes||[]).forEach(shape=>{
        const p=elNS('path');
        p.setAttribute('d', roundedPolygonPath(shape, 10));
        p.setAttribute('fill', color);
        p.setAttribute('fill-opacity', '0.31');
        p.setAttribute('stroke','none');
        p.style.filter='url(#fuzzyEdge)';
        p.addEventListener('click', (e)=> showTooltipFor(f, e));
        g.appendChild(p);
      });
      g.addEventListener('click', (e)=> showTooltipFor(f,e));
      g.addEventListener('mouseenter', ()=> g.classList.add('hover'));
      g.addEventListener('mouseleave', ()=> g.classList.remove('hover'));
      gRegions.appendChild(g);
    });

    // Points
    feats.filter(f=>f.type==='point').forEach(f=>{
      const g=elNS('g'); g.classList.add('feature','point'); g.dataset.id=f.id||'';
      const c=elNS('circle'); c.setAttribute('cx', f.x); c.setAttribute('cy', f.y); c.setAttribute('r', 18);
      const t=elNS('text'); t.setAttribute('x', f.x+30); t.setAttribute('y', f.y-30); t.classList.add('label'); t.textContent=f.name||'';
      const open=(e)=> showTooltipFor(f,e);
      c.addEventListener('click', open); t.addEventListener('click', open);
      g.appendChild(c); g.appendChild(t); gPoints.appendChild(g);
    });
  }

  function showTooltipFor(f, evt){
    if(!f) return;
    const isMobile = window.matchMedia('(max-width: 760px)').matches;
    const name = f.name || '—';
    const desc = f.desc || '';
    const src = f.img || f.image || f.imageUrl || null;

    if(isMobile){
      // Mobile: render into Campaign Info WITH image, no auto-scroll
      loreTitle.textContent = name;
      loreBody.textContent = desc;
      if(src){
        loreImg.src = src; loreImg.alt = name + ' image';
        loreMedia.style.display='block';
      } else {
        loreImg.removeAttribute('src');
        loreMedia.style.display='none';
      }
      // Ensure floating tooltip stays closed on mobile
      tooltip.classList.remove('open');
    }else{
      // Desktop: floating tooltip only; panel mirrors TEXT ONLY (no image)
      ttTitle.textContent = name;
      ttBody.innerHTML = '<p>' + (desc? escapeHTML(desc) : '—') + '</p>';
      if(src){ ttImg.src = src; ttImg.alt = name+' image'; ttMedia.style.display='block'; }
      else { ttImg.removeAttribute('src'); ttMedia.style.display='none'; }
      tooltip.classList.add('open');
      positionTooltip(evt);

      // Mirror text only
      loreTitle.textContent = name;
      loreBody.textContent = desc;
      loreImg.removeAttribute('src');
      loreMedia.style.display='none';
    }
  }

  function positionTooltip(evt){
    const wrapRect = mapWrap.getBoundingClientRect();
    const ttRect = tooltip.getBoundingClientRect();
    const cx = (evt && evt.clientX) || (wrapRect.left + wrapRect.width/2);
    const cy = (evt && evt.clientY) || (wrapRect.top + wrapRect.height/2);
    let x = cx - wrapRect.left + 12;
    let y = cy - wrapRect.top + 12;
    const maxX = wrapRect.width - ttRect.width - 8;
    const maxY = wrapRect.height - ttRect.height - 8;
    x = Math.max(8, Math.min(maxX, x)); y = Math.max(8, Math.min(maxY, y));
    tooltip.style.left = x + 'px'; tooltip.style.top = y + 'px';
  }

})();
</script>
</body>
</html>
